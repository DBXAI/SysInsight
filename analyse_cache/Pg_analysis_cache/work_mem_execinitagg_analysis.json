{
  "param_name": "work_mem",
  "function_name": "ExecInitAgg",
  "analysis": "1. Parameters affect database performance by controlling key functions:\n   - `work_mem` affects database performance by controlling the memory allocation limit mechanism in `ExecInitAgg`.\n   - Mechanism: `work_mem` determines the memory usage limits for the `CreateWorkExprContext` and `build_hash_tables` functions. In `CreateWorkExprContext`, `work_mem` affects the size of the maximum memory block, thereby controlling the memory allocation for `ExprContext`. In the `build_hash_tables` function, `work_mem` affects the memory limit for hash tables, which in turn affects the size and number of partitions of the hash tables.\n   - Database performance impact: When the `work_mem` value is too small, it may lead to insufficient memory, causing hash tables to spill over to disk, increasing I/O operations and reducing performance. If the value is too large, it may waste memory resources and affect the overall memory usage efficiency of the system. By appropriately adjusting `work_mem`, the processing memory of `ExecInitAgg` can be increased, reducing I/O operations, improving memory usage efficiency, and enhancing aggregate query performance.\n\n2. Based on the execution state of `ExecInitAgg` and related function segments, provide `work_mem` optimization suggestions:\n   - If `CreateWorkExprContext` and `build_hash_tables` are involved, indicate whether other functions need to be monitored in addition to `ExecInitAgg`.\n   - According to the flame graph sampling rate, if `CreateWorkExprContext` or `build_hash_tables` is found to take a significant amount of time, it is necessary to increase `work_mem` to reduce bottlenecks in memory allocation or hash table construction. If the flame graph shows insufficient resource usage or excessive heap/stack space switching, reduce `work_mem` to optimize total memory consumption. Specific recommendations for adjustment should be based on monitoring the `maxBlockSize` in `CreateWorkExprContext` and the `memory` parameter in `build_hash_tables`, combined with the proportion data from the flame graph.",
  "code_snippets": "ExecInitAgg(Agg *node, EState *estate, int eflags)\n{\n\tAggState   *aggstate;\n\tAggStatePerAgg peraggs;\n\tAggStatePerTrans pertransstates;\n\tAggStatePerGroup *pergroups;\n\tPlan\t   *outerPlan;\n\tExprContext *econtext;\n\tTupleDesc\tscanDesc;\n\tint\t\t\tmax_aggno;\n\tint\t\t\tmax_transno;\n\tint\t\t\tnumaggrefs;\n\tint\t\t\tnumaggs;\n\tint\t\t\tnumtrans;\n\tint\t\t\tphase;\n\tint\t\t\tphaseidx;\n\tListCell   *l;\n\tBitmapset  *all_grouped_cols = NULL;\n\tint\t\t\tnumGroupingSets = 1;\n\tint\t\t\tnumPhases;\n\tint\t\t\tnumHashes;\n\tint\t\t\ti = 0;\n\tint\t\t\tj = 0;\n\tbool\t\tuse_hashing = (node->aggstrategy == AGG_HASHED ||\n\t\t\t\t\t\t\t   node->aggstrategy == AGG_MIXED);\n\n\t/* check for unsupported flags */\n\tAssert(!(eflags & (EXEC_FLAG_BACKWARD | EXEC_FLAG_MARK)));\n\n\t/*\n\t * create state structure\n\t */\n\taggstate = makeNode(AggState);\n\taggstate->ss.ps.plan = (Plan *) node;\n\taggstate->ss.ps.state = estate;\n\taggstate->ss.ps.ExecProcNode = ExecAgg;\n\n\taggstate->aggs = NIL;\n\taggstate->numaggs = 0;\n\taggstate->numtrans = 0;\n\taggstate->aggstrategy = node->aggstrategy;\n\taggstate->aggsplit = node->aggsplit;\n\taggstate->maxsets = 0;\n\taggstate->projected_set = -1;\n\taggstate->current_set = 0;\n\taggstate->peragg = NULL;\n\taggstate->pertrans = NULL;\n\taggstate->curperagg = NULL;\n\taggstate->curpertrans = NULL;\n\taggstate->input_done = false;\n\taggstate->agg_done = false;\n\taggstate->pergroups = NULL;\n\taggstate->grp_firstTuple = NULL;\n\taggstate->sort_in = NULL;\n\taggstate->sort_out = NULL;\n\n\t/*\n\t * phases[0] always exists, but is dummy in sorted/plain mode\n\t */\n\tnumPhases = (use_hashing ? 1 : 2);\n\tnumHashes = (use_hashing ? 1 : 0);\n\n\t/*\n\t * Calculate the maximum number of grouping sets in any phase; this\n\t * determines the size of some allocations.  Also calculate the number of\n\t * phases, since all hashed/mixed nodes contribute to only a single phase.\n\t */\n\tif (node->groupingSets)\n\t{\n\t\tnumGroupingSets = list_length(node->groupingSets);\n\n\t\tforeach(l, node->chain)\n\t\t{\n\t\t\tAgg\t\t   *agg = lfirst(l);\n\n\t\t\tnumGroupingSets = Max(numGroupingSets,\n\t\t\t\t\t\t\t\t  list_length(agg->groupingSets));\n\n\t\t\t/*\n\t\t\t * additional AGG_HASHED aggs become part of phase 0, but all\n\t\t\t * others add an extra phase.\n\t\t\t */\n\t\t\tif (agg->aggstrategy != AGG_HASHED)\n\t\t\t\t++numPhases;\n\t\t\telse\n\t\t\t\t++numHashes;\n\t\t}\n\t}\n\n\taggstate->maxsets = numGroupingSets;\n\taggstate->numphases = numPhases;\n\n\taggstate->aggcontexts = (ExprContext **)\n\t\tpalloc0(sizeof(ExprContext *) * numGroupingSets);\n\n\t/*\n\t * Create expression contexts.  We need three or more, one for\n\t * per-input-tuple processing, one for per-output-tuple processing, one\n\t * for all the hashtables, and one for each grouping set.  The per-tuple\n\t * memory context of the per-grouping-set ExprContexts (aggcontexts)\n\t * replaces the standalone memory context formerly used to hold transition\n\t * values.  We cheat a little by using ExecAssignExprContext() to build\n\t * all of them.\n\t *\n\t * NOTE: the details of what is stored in aggcontexts and what is stored\n\t * in the regular per-query memory context are driven by a simple\n\t * decision: we want to reset the aggcontext at group boundaries (if not\n\t * hashing) and in ExecReScanAgg to recover no-longer-wanted space.\n\t */\n\tExecAssignExprContext(estate, &aggstate->ss.ps);\n\taggstate->tmpcontext = aggstate->ss.ps.ps_ExprContext;\n\n\tfor (i = 0; i < numGroupingSets; ++i)\n\t{\n\t\tExecAssignExprContext(estate, &aggstate->ss.ps);\n\t\taggstate->aggcontexts[i] = aggstate->ss.ps.ps_ExprContext;\n\t}\n\n\tif (use_hashing)\n\t\taggstate->hashcontext = CreateWorkExprContext(estate);\n\n\tExecAssignExprContext(estate, &aggstate->ss.ps);\n\n\t/*\n\t * Initialize child nodes.\n\t *\n\t * If we are doing a hashed aggregation then the child plan does not need\n\t * to handle REWIND efficiently; see ExecReScanAgg.\n\t */\n\tif (node->aggstrategy == AGG_HASHED)\n\t\teflags &= ~EXEC_FLAG_REWIND;\n\touterPlan = outerPlan(node);\n\touterPlanState(aggstate) = ExecInitNode(outerPlan, estate, eflags);\n\n\t/*\n\t * initialize source tuple type.\n\t */\n\taggstate->ss.ps.outerops =\n\t\tExecGetResultSlotOps(outerPlanState(&aggstate->ss),\n\t\t\t\t\t\t\t &aggstate->ss.ps.outeropsfixed);\n\taggstate->ss.ps.outeropsset = true;\n\n\tExecCreateScanSlotFromOuterPlan(estate, &aggstate->ss,\n\t\t\t\t\t\t\t\t\taggstate->ss.ps.outerops);\n\tscanDesc = aggstate->ss.ss_ScanTupleSlot->tts_tupleDescriptor;\n\n\t/*\n\t * If there are more than two phases (including a potential dummy phase\n\t * 0), input will be resorted using tuplesort. Need a slot for that.\n\t */\n\tif (numPhases > 2)\n\t{\n\t\taggstate->sort_slot = ExecInitExtraTupleSlot(estate, scanDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &TTSOpsMinimalTuple);\n\n\t\t/*\n\t\t * The output of the tuplesort, and the output from the outer child\n\t\t * might not use the same type of slot. In most cases the child will\n\t\t * be a Sort, and thus return a TTSOpsMinimalTuple type slot - but the\n\t\t * input can also be presorted due an index, in which case it could be\n\t\t * a different type of slot.\n\t\t *\n\t\t * XXX: For efficiency it would be good to instead/additionally\n\t\t * generate expressions with corresponding settings of outerops* for\n\t\t * the individual phases - deforming is often a bottleneck for\n\t\t * aggregations with lots of rows per group. If there's multiple\n\t\t * sorts, we know that all but the first use TTSOpsMinimalTuple (via\n\t\t * the nodeAgg.c internal tuplesort).\n\t\t */\n\t\tif (aggstate->ss.ps.outeropsfixed &&\n\t\t\taggstate->ss.ps.outerops != &TTSOpsMinimalTuple)\n\t\t\taggstate->ss.ps.outeropsfixed = false;\n\t}\n\n\t/*\n\t * Initialize result type, slot and projection.\n\t */\n\tExecInitResultTupleSlotTL(&aggstate->ss.ps, &TTSOpsVirtual);\n\tExecAssignProjectionInfo(&aggstate->ss.ps, NULL);\n\n\t/*\n\t * initialize child expressions\n\t *\n\t * We expect the parser to have checked that no aggs contain other agg\n\t * calls in their arguments (and just to be sure, we verify it again while\n\t * initializing the plan node).  This would make no sense under SQL\n\t * semantics, and it's forbidden by the spec.  Because it is true, we\n\t * don't need to worry about evaluating the aggs in any particular order.\n\t *\n\t * Note: execExpr.c finds Aggrefs for us, and adds them to aggstate->aggs.\n\t * Aggrefs in the qual are found here; Aggrefs in the targetlist are found\n\t * during ExecAssignProjectionInfo, above.\n\t */\n\taggstate->ss.ps.qual =\n\t\tExecInitQual(node->plan.qual, (PlanState *) aggstate);\n\n\t/*\n\t * We should now have found all Aggrefs in the targetlist and quals.\n\t */\n\tnumaggrefs = list_length(aggstate->aggs);\n\tmax_aggno = -1;\n\tmax_transno = -1;\n\tforeach(l, aggstate->aggs)\n\t{\n\t\tAggref\t   *aggref = (Aggref *) lfirst(l);\n\n\t\tmax_aggno = Max(max_aggno, aggref->aggno);\n\t\tmax_transno = Max(max_transno, aggref->aggtransno);\n\t}\n\tnumaggs = max_aggno + 1;\n\tnumtrans = max_transno + 1;\n\n\t/*\n\t * For each phase, prepare grouping set data and fmgr lookup data for\n\t * compare functions.  Accumulate all_grouped_cols in passing.\n\t */\n\taggstate->phases = palloc0(numPhases * sizeof(AggStatePerPhaseData));\n\n\taggstate->num_hashes = numHashes;\n\tif (numHashes)\n\t{\n\t\taggstate->perhash = palloc0(sizeof(AggStatePerHashData) * numHashes);\n\t\taggstate->phases[0].numsets = 0;\n\t\taggstate->phases[0].gset_lengths = palloc(numHashes * sizeof(int));\n\t\taggstate->phases[0].grouped_cols = palloc(numHashes * sizeof(Bitmapset *));\n\t}\n\n\tphase = 0;\n\tfor (phaseidx = 0; phaseidx <= list_length(node->chain); ++phaseidx)\n\t{\n\t\tAgg\t\t   *aggnode;\n\t\tSort\t   *sortnode;\n\n\t\tif (phaseidx > 0)\n\t\t{\n\t\t\taggnode = list_nth_node(Agg, node->chain, phaseidx - 1);\n\t\t\tsortnode = castNode(Sort, outerPlan(aggnode));\n\t\t}\n\t\telse\n\t\t{\n\t\t\taggnode = node;\n\t\t\tsortnode = NULL;\n\t\t}\n\n\t\tAssert(phase <= 1 || sortnode);\n\n\t\tif (aggnode->aggstrategy == AGG_HASHED\n\t\t\t|| aggnode->aggstrategy == AGG_MIXED)\n\t\t{\n\t\t\tAggStatePerPhase phasedata = &aggstate->phases[0];\n\t\t\tAggStatePerHash perhash;\n\t\t\tBitmapset  *cols = NULL;\n\n\t\t\tAssert(phase == 0);\n\t\t\ti = phasedata->numsets++;\n\t\t\tperhash = &aggstate->perhash[i];\n\n\t\t\t/* phase 0 always points to the \"real\" Agg in the hash case */\n\t\t\tphasedata->aggnode = node;\n\t\t\tphasedata->aggstrategy = node->aggstrategy;\n\n\t\t\t/* but the actual Agg node representing this hash is saved here */\n\t\t\tperhash->aggnode = aggnode;\n\n\t\t\tphasedata->gset_lengths[i] = perhash->numCols = aggnode->numCols;\n\n\t\t\tfor (j = 0; j < aggnode->numCols; ++j)\n\t\t\t\tcols = bms_add_member(cols, aggnode->grpColIdx[j]);\n\n\t\t\tphasedata->grouped_cols[i] = cols;\n\n\t\t\tall_grouped_cols = bms_add_members(all_grouped_cols, cols);\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAggStatePerPhase phasedata = &aggstate->phases[++phase];\n\t\t\tint\t\t\tnum_sets;\n\n\t\t\tphasedata->numsets = num_sets = list_length(aggnode->groupingSets);\n\n\t\t\tif (num_sets)\n\t\t\t{\n\t\t\t\tphasedata->gset_lengths = palloc(num_sets * sizeof(int));\n\t\t\t\tphasedata->grouped_cols = palloc(num_sets * sizeof(Bitmapset *));\n\n\t\t\t\ti = 0;\n\t\t\t\tforeach(l, aggnode->groupingSets)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tcurrent_length = list_length(lfirst(l));\n\t\t\t\t\tBitmapset  *cols = NULL;\n\n\t\t\t\t\t/* planner forces this to be correct */\n\t\t\t\t\tfor (j = 0; j < current_length; ++j)\n\t\t\t\t\t\tcols = bms_add_member(cols, aggnode->grpColIdx[j]);\n\n\t\t\t\t\tphasedata->grouped_cols[i] = cols;\n\t\t\t\t\tphasedata->gset_lengths[i] = current_length;\n\n\t\t\t\t\t++i;\n\t\t\t\t}\n\n\t\t\t\tall_grouped_cols = bms_add_members(all_grouped_cols,\n\t\t\t\t\t\t\t\t\t\t\t\t   phasedata->grouped_cols[0]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(phaseidx == 0);\n\n\t\t\t\tphasedata->gset_lengths = NULL;\n\t\t\t\tphasedata->grouped_cols = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we are grouping, precompute fmgr lookup data for inner loop.\n\t\t\t */\n\t\t\tif (aggnode->aggstrategy == AGG_SORTED)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Build a separate function for each subset of columns that\n\t\t\t\t * need to be compared.\n\t\t\t\t */\n\t\t\t\tphasedata->eqfunctions =\n\t\t\t\t\t(ExprState **) palloc0(aggnode->numCols * sizeof(ExprState *));\n\n\t\t\t\t/* for each grouping set */\n\t\t\t\tfor (int k = 0; k < phasedata->numsets; k++)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tlength = phasedata->gset_lengths[k];\n\n\t\t\t\t\t/* nothing to do for empty grouping set */\n\t\t\t\t\tif (length == 0)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t/* if we already had one of this length, it'll do */\n\t\t\t\t\tif (phasedata->eqfunctions[length - 1] != NULL)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tphasedata->eqfunctions[length - 1] =\n\t\t\t\t\t\texecTuplesMatchPrepare(scanDesc,\n\t\t\t\t\t\t\t\t\t\t\t   length,\n\t\t\t\t\t\t\t\t\t\t\t   aggnode->grpColIdx,\n\t\t\t\t\t\t\t\t\t\t\t   aggnode->grpOperators,\n\t\t\t\t\t\t\t\t\t\t\t   aggnode->grpCollations,\n\t\t\t\t\t\t\t\t\t\t\t   (PlanState *) aggstate);\n\t\t\t\t}\n\n\t\t\t\t/* and for all grouped columns, unless already computed */\n\t\t\t\tif (aggnode->numCols > 0 &&\n\t\t\t\t\tphasedata->eqfunctions[aggnode->numCols - 1] == NULL)\n\t\t\t\t{\n\t\t\t\t\tphasedata->eqfunctions[aggnode->numCols - 1] =\n\t\t\t\t\t\texecTuplesMatchPrepare(scanDesc,\n\t\t\t\t\t\t\t\t\t\t\t   aggnode->numCols,\n\t\t\t\t\t\t\t\t\t\t\t   aggnode->grpColIdx,\n\t\t\t\t\t\t\t\t\t\t\t   aggnode->grpOperators,\n\t\t\t\t\t\t\t\t\t\t\t   aggnode->grpCollations,\n\t\t\t\t\t\t\t\t\t\t\t   (PlanState *) aggstate);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tphasedata->aggnode = aggnode;\n\t\t\tphasedata->aggstrategy = aggnode->aggstrategy;\n\t\t\tphasedata->sortnode = sortnode;\n\t\t}\n\t}\n\n\t/*\n\t * Convert all_grouped_cols to a descending-order list.\n\t */\n\ti = -1;\n\twhile ((i = bms_next_member(all_grouped_cols, i)) >= 0)\n\t\taggstate->all_grouped_cols = lcons_int(i, aggstate->all_grouped_cols);\n\n\t/*\n\t * Set up aggregate-result storage in the output expr context, and also\n\t * allocate my private per-agg working storage\n\t */\n\tecontext = aggstate->ss.ps.ps_ExprContext;\n\tecontext->ecxt_aggvalues = (Datum *) palloc0(sizeof(Datum) * numaggs);\n\tecontext->ecxt_aggnulls = (bool *) palloc0(sizeof(bool) * numaggs);\n\n\tperaggs = (AggStatePerAgg) palloc0(sizeof(AggStatePerAggData) * numaggs);\n\tpertransstates = (AggStatePerTrans) palloc0(sizeof(AggStatePerTransData) * numtrans);\n\n\taggstate->peragg = peraggs;\n\taggstate->pertrans = pertransstates;\n\n\n\taggstate->all_pergroups =\n\t\t(AggStatePerGroup *) palloc0(sizeof(AggStatePerGroup)\n\t\t\t\t\t\t\t\t\t * (numGroupingSets + numHashes));\n\tpergroups = aggstate->all_pergroups;\n\n\tif (node->aggstrategy != AGG_HASHED)\n\t{\n\t\tfor (i = 0; i < numGroupingSets; i++)\n\t\t{\n\t\t\tpergroups[i] = (AggStatePerGroup) palloc0(sizeof(AggStatePerGroupData)\n\t\t\t\t\t\t\t\t\t\t\t\t\t  * numaggs);\n\t\t}\n\n\t\taggstate->pergroups = pergroups;\n\t\tpergroups += numGroupingSets;\n\t}\n\n\t/*\n\t * Hashing can only appear in the initial phase.\n\t */\n\tif (use_hashing)\n\t{\n\t\tPlan\t   *outerplan = outerPlan(node);\n\t\tuint64\t\ttotalGroups = 0;\n\n\t\taggstate->hash_metacxt = AllocSetContextCreate(aggstate->ss.ps.state->es_query_cxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   \"HashAgg meta context\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t\taggstate->hash_spill_rslot = ExecInitExtraTupleSlot(estate, scanDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&TTSOpsMinimalTuple);\n\t\taggstate->hash_spill_wslot = ExecInitExtraTupleSlot(estate, scanDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&TTSOpsVirtual);\n\n\t\t/* this is an array of pointers, not structures */\n\t\taggstate->hash_pergroup = pergroups;\n\n\t\taggstate->hashentrysize = hash_agg_entry_size(aggstate->numtrans,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  outerplan->plan_width,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  node->transitionSpace);\n\n\t\t/*\n\t\t * Consider all of the grouping sets together when setting the limits\n\t\t * and estimating the number of partitions. This can be inaccurate\n\t\t * when there is more than one grouping set, but should still be\n\t\t * reasonable.\n\t\t */\n\t\tfor (int k = 0; k < aggstate->num_hashes; k++)\n\t\t\ttotalGroups += aggstate->perhash[k].aggnode->numGroups;\n\n\t\thash_agg_set_limits(aggstate->hashentrysize, totalGroups, 0,\n\t\t\t\t\t\t\t&aggstate->hash_mem_limit,\n\t\t\t\t\t\t\t&aggstate->hash_ngroups_limit,\n\t\t\t\t\t\t\t&aggstate->hash_planned_partitions);\n\t\tfind_hash_columns(aggstate);\n\n\t\t/* Skip massive memory allocation if we are just doing EXPLAIN */\n\t\tif (!(eflags & EXEC_FLAG_EXPLAIN_ONLY))\n\t\t\tbuild_hash_tables(aggstate);\n\n\t\taggstate->table_filled = false;\n\n\t\t/* Initialize this to 1, meaning nothing spilled, yet */\n\t\taggstate->hash_batches_used = 1;\n\t}\n\n\t/*\n\t * Initialize current phase-dependent values to initial phase. The initial\n\t * phase is 1 (first sort pass) for all strategies that use sorting (if\n\t * hashing is being done too, then phase 0 is processed last); but if only\n\t * hashing is being done, then phase 0 is all there is.\n\t */\n\tif (node->aggstrategy == AGG_HASHED)\n\t{\n\t\taggstate->current_phase = 0;\n\t\tinitialize_phase(aggstate, 0);\n\t\tselect_current_set(aggstate, 0, true);\n\t}\n\telse\n\t{\n\t\taggstate->current_phase = 1;\n\t\tinitialize_phase(aggstate, 1);\n\t\tselect_current_set(aggstate, 0, false);\n\t}\n\n\t/*\n\t * Perform lookups of aggregate function info, and initialize the\n\t * unchanging fields of the per-agg and per-trans data.\n\t */\n\tforeach(l, aggstate->aggs)\n\t{\n\t\tAggref\t   *aggref = lfirst(l);\n\t\tAggStatePerAgg peragg;\n\t\tAggStatePerTrans pertrans;\n\t\tOid\t\t\taggTransFnInputTypes[FUNC_MAX_ARGS];\n\t\tint\t\t\tnumAggTransFnArgs;\n\t\tint\t\t\tnumDirectArgs;\n\t\tHeapTuple\taggTuple;\n\t\tForm_pg_aggregate aggform;\n\t\tAclResult\taclresult;\n\t\tOid\t\t\tfinalfn_oid;\n\t\tOid\t\t\tserialfn_oid,\n\t\t\t\t\tdeserialfn_oid;\n\t\tOid\t\t\taggOwner;\n\t\tExpr\t   *finalfnexpr;\n\t\tOid\t\t\taggtranstype;\n\n\t\t/* Planner should have assigned aggregate to correct level */\n\t\tAssert(aggref->agglevelsup == 0);\n\t\t/* ... and the split mode should match */\n\t\tAssert(aggref->aggsplit == aggstate->aggsplit);\n\n\t\tperagg = &peraggs[aggref->aggno];\n\n\t\t/* Check if we initialized the state for this aggregate already. */\n\t\tif (peragg->aggref != NULL)\n\t\t\tcontinue;\n\n\t\tperagg->aggref = aggref;\n\t\tperagg->transno = aggref->aggtransno;\n\n\t\t/* Fetch the pg_aggregate row */\n\t\taggTuple = SearchSysCache1(AGGFNOID,\n\t\t\t\t\t\t\t\t   ObjectIdGetDatum(aggref->aggfnoid));\n\t\tif (!HeapTupleIsValid(aggTuple))\n\t\t\telog(ERROR, \"cache lookup failed for aggregate %u\",\n\t\t\t\t aggref->aggfnoid);\n\t\taggform = (Form_pg_aggregate) GETSTRUCT(aggTuple);\n\n\t\t/* Check permission to call aggregate function */\n\t\taclresult = object_aclcheck(ProcedureRelationId, aggref->aggfnoid, GetUserId(),\n\t\t\t\t\t\t\t\t\tACL_EXECUTE);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t\taclcheck_error(aclresult, OBJECT_AGGREGATE,\n\t\t\t\t\t\t   get_func_name(aggref->aggfnoid));\n\t\tInvokeFunctionExecuteHook(aggref->aggfnoid);\n\n\t\t/* planner recorded transition state type in the Aggref itself */\n\t\taggtranstype = aggref->aggtranstype;\n\t\tAssert(OidIsValid(aggtranstype));\n\n\t\t/* Final function only required if we're finalizing the aggregates */\n\t\tif (DO_AGGSPLIT_SKIPFINAL(aggstate->aggsplit))\n\t\t\tperagg->finalfn_oid = finalfn_oid = InvalidOid;\n\t\telse\n\t\t\tperagg->finalfn_oid = finalfn_oid = aggform->aggfinalfn;\n\n\t\tserialfn_oid = InvalidOid;\n\t\tdeserialfn_oid = InvalidOid;\n\n\t\t/*\n\t\t * Check if serialization/deserialization is required.  We only do it\n\t\t * for aggregates that have transtype INTERNAL.\n\t\t */\n\t\tif (aggtranstype == INTERNALOID)\n\t\t{\n\t\t\t/*\n\t\t\t * The planner should only have generated a serialize agg node if\n\t\t\t * every aggregate with an INTERNAL state has a serialization\n\t\t\t * function.  Verify that.\n\t\t\t */\n\t\t\tif (DO_AGGSPLIT_SERIALIZE(aggstate->aggsplit))\n\t\t\t{\n\t\t\t\t/* serialization only valid when not running finalfn */\n\t\t\t\tAssert(DO_AGGSPLIT_SKIPFINAL(aggstate->aggsplit));\n\n\t\t\t\tif (!OidIsValid(aggform->aggserialfn))\n\t\t\t\t\telog(ERROR, \"serialfunc not provided for serialization aggregation\");\n\t\t\t\tserialfn_oid = aggform->aggserialfn;\n\t\t\t}\n\n\t\t\t/* Likewise for deserialization functions */\n\t\t\tif (DO_AGGSPLIT_DESERIALIZE(aggstate->aggsplit))\n\t\t\t{\n\t\t\t\t/* deserialization only valid when combining states */\n\t\t\t\tAssert(DO_AGGSPLIT_COMBINE(aggstate->aggsplit));\n\n\t\t\t\tif (!OidIsValid(aggform->aggdeserialfn))\n\t\t\t\t\telog(ERROR, \"deserialfunc not provided for deserialization aggregation\");\n\t\t\t\tdeserialfn_oid = aggform->aggdeserialfn;\n\t\t\t}\n\t\t}\n\n\t\t/* Check that aggregate owner has permission to call component fns */\n\t\t{\n\t\t\tHeapTuple\tprocTuple;\n\n\t\t\tprocTuple = SearchSysCache1(PROCOID,\n\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(aggref->aggfnoid));\n\t\t\tif (!HeapTupleIsValid(procTuple))\n\t\t\t\telog(ERROR, \"cache lookup failed for function %u\",\n\t\t\t\t\t aggref->aggfnoid);\n\t\t\taggOwner = ((Form_pg_proc) GETSTRUCT(procTuple))->proowner;\n\t\t\tReleaseSysCache(procTuple);\n\n\t\t\tif (OidIsValid(finalfn_oid))\n\t\t\t{\n\t\t\t\taclresult = object_aclcheck(ProcedureRelationId, finalfn_oid, aggOwner,\n\t\t\t\t\t\t\t\t\t\t\tACL_EXECUTE);\n\t\t\t\tif (aclresult != ACLCHECK_OK)\n\t\t\t\t\taclcheck_error(aclresult, OBJECT_FUNCTION,\n\t\t\t\t\t\t\t\t   get_func_name(finalfn_oid));\n\t\t\t\tInvokeFunctionExecuteHook(finalfn_oid);\n\t\t\t}\n\t\t\tif (OidIsValid(serialfn_oid))\n\t\t\t{\n\t\t\t\taclresult = object_aclcheck(ProcedureRelationId, serialfn_oid, aggOwner,\n\t\t\t\t\t\t\t\t\t\t\tACL_EXECUTE);\n\t\t\t\tif (aclresult != ACLCHECK_OK)\n\t\t\t\t\taclcheck_error(aclresult, OBJECT_FUNCTION,\n\t\t\t\t\t\t\t\t   get_func_name(serialfn_oid));\n\t\t\t\tInvokeFunctionExecuteHook(serialfn_oid);\n\t\t\t}\n\t\t\tif (OidIsValid(deserialfn_oid))\n\t\t\t{\n\t\t\t\taclresult = object_aclcheck(ProcedureRelationId, deserialfn_oid, aggOwner,\n\t\t\t\t\t\t\t\t\t\t\tACL_EXECUTE);\n\t\t\t\tif (aclresult != ACLCHECK_OK)\n\t\t\t\t\taclcheck_error(aclresult, OBJECT_FUNCTION,\n\t\t\t\t\t\t\t\t   get_func_name(deserialfn_oid));\n\t\t\t\tInvokeFunctionExecuteHook(deserialfn_oid);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Get actual datatypes of the (nominal) aggregate inputs.  These\n\t\t * could be different from the agg's declared input types, when the\n\t\t * agg accepts ANY or a polymorphic type.\n\t\t */\n\t\tnumAggTransFnArgs = get_aggregate_argtypes(aggref,\n\t\t\t\t\t\t\t\t\t\t\t\t   aggTransFnInputTypes);\n\n\t\t/* Count the \"direct\" arguments, if any */\n\t\tnumDirectArgs = list_length(aggref->aggdirectargs);\n\n\t\t/* Detect how many arguments to pass to the finalfn */\n\t\tif (aggform->aggfinalextra)\n\t\t\tperagg->numFinalArgs = numAggTransFnArgs + 1;\n\t\telse\n\t\t\tperagg->numFinalArgs = numDirectArgs + 1;\n\n\t\t/* Initialize any direct-argument expressions */\n\t\tperagg->aggdirectargs = ExecInitExprList(aggref->aggdirectargs,\n\t\t\t\t\t\t\t\t\t\t\t\t (PlanState *) aggstate);\n\n\t\t/*\n\t\t * build expression trees using actual argument & result types for the\n\t\t * finalfn, if it exists and is required.\n\t\t */\n\t\tif (OidIsValid(finalfn_oid))\n\t\t{\n\t\t\tbuild_aggregate_finalfn_expr(aggTransFnInputTypes,\n\t\t\t\t\t\t\t\t\t\t peragg->numFinalArgs,\n\t\t\t\t\t\t\t\t\t\t aggtranstype,\n\t\t\t\t\t\t\t\t\t\t aggref->aggtype,\n\t\t\t\t\t\t\t\t\t\t aggref->inputcollid,\n\t\t\t\t\t\t\t\t\t\t finalfn_oid,\n\t\t\t\t\t\t\t\t\t\t &finalfnexpr);\n\t\t\tfmgr_info(finalfn_oid, &peragg->finalfn);\n\t\t\tfmgr_info_set_expr((Node *) finalfnexpr, &peragg->finalfn);\n\t\t}\n\n\t\t/* get info about the output value's datatype */\n\t\tget_typlenbyval(aggref->aggtype,\n\t\t\t\t\t\t&peragg->resulttypeLen,\n\t\t\t\t\t\t&peragg->resulttypeByVal);\n\n\t\t/*\n\t\t * Build working state for invoking the transition function, if we\n\t\t * haven't done it already.\n\t\t */\n\t\tpertrans = &pertransstates[aggref->aggtransno];\n\t\tif (pertrans->aggref == NULL)\n\t\t{\n\t\t\tDatum\t\ttextInitVal;\n\t\t\tDatum\t\tinitValue;\n\t\t\tbool\t\tinitValueIsNull;\n\t\t\tOid\t\t\ttransfn_oid;\n\n\t\t\t/*\n\t\t\t * If this aggregation is performing state combines, then instead\n\t\t\t * of using the transition function, we'll use the combine\n\t\t\t * function.\n\t\t\t */\n\t\t\tif (DO_AGGSPLIT_COMBINE(aggstate->aggsplit))\n\t\t\t{\n\t\t\t\ttransfn_oid = aggform->aggcombinefn;\n\n\t\t\t\t/* If not set then the planner messed up */\n\t\t\t\tif (!OidIsValid(transfn_oid))\n\t\t\t\t\telog(ERROR, \"combinefn not set for aggregate function\");\n\t\t\t}\n\t\t\telse\n\t\t\t\ttransfn_oid = aggform->aggtransfn;\n\n\t\t\taclresult = object_aclcheck(ProcedureRelationId, transfn_oid, aggOwner, ACL_EXECUTE);\n\t\t\tif (aclresult != ACLCHECK_OK)\n\t\t\t\taclcheck_error(aclresult, OBJECT_FUNCTION,\n\t\t\t\t\t\t\t   get_func_name(transfn_oid));\n\t\t\tInvokeFunctionExecuteHook(transfn_oid);\n\n\t\t\t/*\n\t\t\t * initval is potentially null, so don't try to access it as a\n\t\t\t * struct field. Must do it the hard way with SysCacheGetAttr.\n\t\t\t */\n\t\t\ttextInitVal = SysCacheGetAttr(AGGFNOID, aggTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_aggregate_agginitval,\n\t\t\t\t\t\t\t\t\t\t  &initValueIsNull);\n\t\t\tif (initValueIsNull)\n\t\t\t\tinitValue = (Datum) 0;\n\t\t\telse\n\t\t\t\tinitValue = GetAggInitVal(textInitVal, aggtranstype);\n\n\t\t\tif (DO_AGGSPLIT_COMBINE(aggstate->aggsplit))\n\t\t\t{\n\t\t\t\tOid\t\t\tcombineFnInputTypes[] = {aggtranstype,\n\t\t\t\taggtranstype};\n\n\t\t\t\t/*\n\t\t\t\t * When combining there's only one input, the to-be-combined\n\t\t\t\t * transition value.  The transition value is not counted\n\t\t\t\t * here.\n\t\t\t\t */\n\t\t\t\tpertrans->numTransInputs = 1;\n\n\t\t\t\t/* aggcombinefn always has two arguments of aggtranstype */\n\t\t\t\tbuild_pertrans_for_aggref(pertrans, aggstate, estate,\n\t\t\t\t\t\t\t\t\t\t  aggref, transfn_oid, aggtranstype,\n\t\t\t\t\t\t\t\t\t\t  serialfn_oid, deserialfn_oid,\n\t\t\t\t\t\t\t\t\t\t  initValue, initValueIsNull,\n\t\t\t\t\t\t\t\t\t\t  combineFnInputTypes, 2);\n\n\t\t\t\t/*\n\t\t\t\t * Ensure that a combine function to combine INTERNAL states\n\t\t\t\t * is not strict. This should have been checked during CREATE\n\t\t\t\t * AGGREGATE, but the strict property could have been changed\n\t\t\t\t * since then.\n\t\t\t\t */\n\t\t\t\tif (pertrans->transfn.fn_strict && aggtranstype == INTERNALOID)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),\n\t\t\t\t\t\t\t errmsg(\"combine function with transition type %s must not be declared STRICT\",\n\t\t\t\t\t\t\t\t\tformat_type_be(aggtranstype))));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Detect how many arguments to pass to the transfn */\n\t\t\t\tif (AGGKIND_IS_ORDERED_SET(aggref->aggkind))\n\t\t\t\t\tpertrans->numTransInputs = list_length(aggref->args);\n\t\t\t\telse\n\t\t\t\t\tpertrans->numTransInputs = numAggTransFnArgs;\n\n\t\t\t\tbuild_pertrans_for_aggref(pertrans, aggstate, estate,\n\t\t\t\t\t\t\t\t\t\t  aggref, transfn_oid, aggtranstype,\n\t\t\t\t\t\t\t\t\t\t  serialfn_oid, deserialfn_oid,\n\t\t\t\t\t\t\t\t\t\t  initValue, initValueIsNull,\n\t\t\t\t\t\t\t\t\t\t  aggTransFnInputTypes,\n\t\t\t\t\t\t\t\t\t\t  numAggTransFnArgs);\n\n\t\t\t\t/*\n\t\t\t\t * If the transfn is strict and the initval is NULL, make sure\n\t\t\t\t * input type and transtype are the same (or at least\n\t\t\t\t * binary-compatible), so that it's OK to use the first\n\t\t\t\t * aggregated input value as the initial transValue.  This\n\t\t\t\t * should have been checked at agg definition time, but we\n\t\t\t\t * must check again in case the transfn's strictness property\n\t\t\t\t * has been changed.\n\t\t\t\t */\n\t\t\t\tif (pertrans->transfn.fn_strict && pertrans->initValueIsNull)\n\t\t\t\t{\n\t\t\t\t\tif (numAggTransFnArgs <= numDirectArgs ||\n\t\t\t\t\t\t!IsBinaryCoercible(aggTransFnInputTypes[numDirectArgs],\n\t\t\t\t\t\t\t\t\t\t   aggtranstype))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),\n\t\t\t\t\t\t\t\t errmsg(\"aggregate %u needs to have compatible input type and transition type\",\n\t\t\t\t\t\t\t\t\t\taggref->aggfnoid)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tpertrans->aggshared = true;\n\t\tReleaseSysCache(aggTuple);\n\t}\n\n\t/*\n\t * Update aggstate->numaggs to be the number of unique aggregates found.\n\t * Also set numstates to the number of unique transition states found.\n\t */\n\taggstate->numaggs = numaggs;\n\taggstate->numtrans = numtrans;\n\n\t/*\n\t * Last, check whether any more aggregates got added onto the node while\n\t * we processed the expressions for the aggregate arguments (including not\n\t * only the regular arguments and FILTER expressions handled immediately\n\t * above, but any direct arguments we might've handled earlier).  If so,\n\t * we have nested aggregate functions, which is semantically nonsensical,\n\t * so complain.  (This should have been caught by the parser, so we don't\n\t * need to work hard on a helpful error message; but we defend against it\n\t * here anyway, just to be sure.)\n\t */\n\tif (numaggrefs != list_length(aggstate->aggs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_GROUPING_ERROR),\n\t\t\t\t errmsg(\"aggregate function calls cannot be nested\")));\n\n\t/*\n\t * Build expressions doing all the transition work at once. We build a\n\t * different one for each phase, as the number of transition function\n\t * invocation can differ between phases. Note this'll work both for\n\t * transition and combination functions (although there'll only be one\n\t * phase in the latter case).\n\t */\n\tfor (phaseidx = 0; phaseidx < aggstate->numphases; phaseidx++)\n\t{\n\t\tAggStatePerPhase phase = &aggstate->phases[phaseidx];\n\t\tbool\t\tdohash = false;\n\t\tbool\t\tdosort = false;\n\n\t\t/* phase 0 doesn't necessarily exist */\n\t\tif (!phase->aggnode)\n\t\t\tcontinue;\n\n\t\tif (aggstate->aggstrategy == AGG_MIXED && phaseidx == 1)\n\t\t{\n\t\t\t/*\n\t\t\t * Phase one, and only phase one, in a mixed agg performs both\n\t\t\t * sorting and aggregation.\n\t\t\t */\n\t\t\tdohash = true;\n\t\t\tdosort = true;\n\t\t}\n\t\telse if (aggstate->aggstrategy == AGG_MIXED && phaseidx == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * No need to compute a transition function for an AGG_MIXED phase\n\t\t\t * 0 - the contents of the hashtables will have been computed\n\t\t\t * during phase 1.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\telse if (phase->aggstrategy == AGG_PLAIN ||\n\t\t\t\t phase->aggstrategy == AGG_SORTED)\n\t\t{\n\t\t\tdohash = false;\n\t\t\tdosort = true;\n\t\t}\n\t\telse if (phase->aggstrategy == AGG_HASHED)\n\t\t{\n\t\t\tdohash = true;\n\t\t\tdosort = false;\n\t\t}\n\t\telse\n\t\t\tAssert(false);\n\n\t\tphase->evaltrans = ExecBuildAggTrans(aggstate, phase, dosort, dohash,\n\t\t\t\t\t\t\t\t\t\t\t false);\n\n\t\t/* cache compiled expression for outer slot without NULL check */\n\t\tphase->evaltrans_cache[0][0] = phase->evaltrans;\n\t}\n\n\treturn aggstate;\n}",
  "timestamp": "2025-10-30T15:57:47.945010"
}