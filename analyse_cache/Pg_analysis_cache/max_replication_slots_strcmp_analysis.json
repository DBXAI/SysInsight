{
  "param_name": "max_replication_slots",
  "function_name": "strcmp",
  "analysis": "1. Parameters control the impact of key functions on database performance:\n   - max_replication_slots affects strcmp through [slot quantity management mechanism], thereby causing [database performance impact].\n   - Mechanism: max_replication_slots determines the maximum number of replication slots that can be created. When replication slots reach the maximum value, the function ReplicationSlotCreate uses strcmp for name comparison for each slot to detect name conflicts. In the code fragment SearchNamedReplicationSlot, strcmp is called to check if the given slot exists. A larger max_replication_slots will lead to more name comparisons, increasing the frequency of strcmp execution.\n   - Database performance impact: If max_replication_slots is set too high, it may lead to performance degradation when creating and searching replication slots because more name comparisons are needed (increased strcmp execution), which may cause delays when the system handles slots on a large scale.\n\n2. Based on the execution status of strcmp and related function fragments, provide optimization suggestions for max_replication_slots:\n   - If other functions are involved, indicate whether monitoring other functions is necessary besides strcmp. Monitoring other functions is not necessary; adjustments are mainly made based on the activity level of strcmp.\n   - How to recommend the direction of adjustment (increase or decrease) for max_replication_slots based on the flame graph sampling rate of strcmp and [other functions], and the basis for it:\n     - If the sampling rate of strcmp in the flame graph is too high, indicating excessive computation due to a large number of slot name comparisons, consider lowering max_replication_slots to reduce the performance overhead caused by slot allocation.\n     - If the sampling rate of strcmp is relatively low and the system's slot demand is not met, consider moderately increasing max_replication_slots to enhance the system's ability to allocate slots.",
  "code_snippets": "CreateRestartPoint(int flags)\n{\n\tXLogRecPtr\tlastCheckPointRecPtr;\n\tXLogRecPtr\tlastCheckPointEndPtr;\n\tCheckPoint\tlastCheckPoint;\n\tXLogRecPtr\tPriorRedoPtr;\n\tXLogRecPtr\treceivePtr;\n\tXLogRecPtr\treplayPtr;\n\tTimeLineID\treplayTLI;\n\tXLogRecPtr\tendptr;\n\tXLogSegNo\t_logSegNo;\n\tTimestampTz xtime;\n\n\t/* Concurrent checkpoint/restartpoint cannot happen */\n\tAssert(!IsUnderPostmaster || MyBackendType == B_CHECKPOINTER);\n\n\t/* Get a local copy of the last safe checkpoint record. */\n\tSpinLockAcquire(&XLogCtl->info_lck);\n\tlastCheckPointRecPtr = XLogCtl->lastCheckPointRecPtr;\n\tlastCheckPointEndPtr = XLogCtl->lastCheckPointEndPtr;\n\tlastCheckPoint = XLogCtl->lastCheckPoint;\n\tSpinLockRelease(&XLogCtl->info_lck);\n\n\t/*\n\t * Check that we're still in recovery mode. It's ok if we exit recovery\n\t * mode after this check, the restart point is valid anyway.\n\t */\n\tif (!RecoveryInProgress())\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"skipping restartpoint, recovery has already ended\")));\n\t\treturn false;\n\t}\n\n\t/*\n\t * If the last checkpoint record we've replayed is already our last\n\t * restartpoint, we can't perform a new restart point. We still update\n\t * minRecoveryPoint in that case, so that if this is a shutdown restart\n\t * point, we won't start up earlier than before. That's not strictly\n\t * necessary, but when hot standby is enabled, it would be rather weird if\n\t * the database opened up for read-only connections at a point-in-time\n\t * before the last shutdown. Such time travel is still possible in case of\n\t * immediate shutdown, though.\n\t *\n\t * We don't explicitly advance minRecoveryPoint when we do create a\n\t * restartpoint. It's assumed that flushing the buffers will do that as a\n\t * side-effect.\n\t */\n\tif (XLogRecPtrIsInvalid(lastCheckPointRecPtr) ||\n\t\tlastCheckPoint.redo <= ControlFile->checkPointCopy.redo)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"skipping restartpoint, already performed at %X/%X\",\n\t\t\t\t\t\t\t\t LSN_FORMAT_ARGS(lastCheckPoint.redo))));\n\n\t\tUpdateMinRecoveryPoint(InvalidXLogRecPtr, true);\n\t\tif (flags & CHECKPOINT_IS_SHUTDOWN)\n\t\t{\n\t\t\tLWLockAcquire(ControlFileLock, LW_EXCLUSIVE);\n\t\t\tControlFile->state = DB_SHUTDOWNED_IN_RECOVERY;\n\t\t\tUpdateControlFile();\n\t\t\tLWLockRelease(ControlFileLock);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * Update the shared RedoRecPtr so that the startup process can calculate\n\t * the number of segments replayed since last restartpoint, and request a\n\t * restartpoint if it exceeds CheckPointSegments.\n\t *\n\t * Like in CreateCheckPoint(), hold off insertions to update it, although\n\t * during recovery this is just pro forma, because no WAL insertions are\n\t * happening.\n\t */\n\tWALInsertLockAcquireExclusive();\n\tRedoRecPtr = XLogCtl->Insert.RedoRecPtr = lastCheckPoint.redo;\n\tWALInsertLockRelease();\n\n\t/* Also update the info_lck-protected copy */\n\tSpinLockAcquire(&XLogCtl->info_lck);\n\tXLogCtl->RedoRecPtr = lastCheckPoint.redo;\n\tSpinLockRelease(&XLogCtl->info_lck);\n\n\t/*\n\t * Prepare to accumulate statistics.\n\t *\n\t * Note: because it is possible for log_checkpoints to change while a\n\t * checkpoint proceeds, we always accumulate stats, even if\n\t * log_checkpoints is currently off.\n\t */\n\tMemSet(&CheckpointStats, 0, sizeof(CheckpointStats));\n\tCheckpointStats.ckpt_start_t = GetCurrentTimestamp();\n\n\tif (log_checkpoints)\n\t\tLogCheckpointStart(flags, true);\n\n\t/* Update the process title */\n\tupdate_checkpoint_display(flags, true, false);\n\n\tCheckPointGuts(lastCheckPoint.redo, flags);\n\n\t/*\n\t * Remember the prior checkpoint's redo ptr for\n\t * UpdateCheckPointDistanceEstimate()\n\t */\n\tPriorRedoPtr = ControlFile->checkPointCopy.redo;\n\n\t/*\n\t * Update pg_control, using current time.  Check that it still shows an\n\t * older checkpoint, else do nothing; this is a quick hack to make sure\n\t * nothing really bad happens if somehow we get here after the\n\t * end-of-recovery checkpoint.\n\t */\n\tLWLockAcquire(ControlFileLock, LW_EXCLUSIVE);\n\tif (ControlFile->checkPointCopy.redo < lastCheckPoint.redo)\n\t{\n\t\t/*\n\t\t * Update the checkpoint information.  We do this even if the cluster\n\t\t * does not show DB_IN_ARCHIVE_RECOVERY to match with the set of WAL\n\t\t * segments recycled below.\n\t\t */\n\t\tControlFile->checkPoint = lastCheckPointRecPtr;\n\t\tControlFile->checkPointCopy = lastCheckPoint;\n\n\t\t/*\n\t\t * Ensure minRecoveryPoint is past the checkpoint record and update it\n\t\t * if the control file still shows DB_IN_ARCHIVE_RECOVERY.  Normally,\n\t\t * this will have happened already while writing out dirty buffers,\n\t\t * but not necessarily - e.g. because no buffers were dirtied.  We do\n\t\t * this because a backup performed in recovery uses minRecoveryPoint\n\t\t * to determine which WAL files must be included in the backup, and\n\t\t * the file (or files) containing the checkpoint record must be\n\t\t * included, at a minimum.  Note that for an ordinary restart of\n\t\t * recovery there's no value in having the minimum recovery point any\n\t\t * earlier than this anyway, because redo will begin just after the\n\t\t * checkpoint record.\n\t\t */\n\t\tif (ControlFile->state == DB_IN_ARCHIVE_RECOVERY)\n\t\t{\n\t\t\tif (ControlFile->minRecoveryPoint < lastCheckPointEndPtr)\n\t\t\t{\n\t\t\t\tControlFile->minRecoveryPoint = lastCheckPointEndPtr;\n\t\t\t\tControlFile->minRecoveryPointTLI = lastCheckPoint.ThisTimeLineID;\n\n\t\t\t\t/* update local copy */\n\t\t\t\tLocalMinRecoveryPoint = ControlFile->minRecoveryPoint;\n\t\t\t\tLocalMinRecoveryPointTLI = ControlFile->minRecoveryPointTLI;\n\t\t\t}\n\t\t\tif (flags & CHECKPOINT_IS_SHUTDOWN)\n\t\t\t\tControlFile->state = DB_SHUTDOWNED_IN_RECOVERY;\n\t\t}\n\t\tUpdateControlFile();\n\t}\n\tLWLockRelease(ControlFileLock);\n\n\t/*\n\t * Update the average distance between checkpoints/restartpoints if the\n\t * prior checkpoint exists.\n\t */\n\tif (PriorRedoPtr != InvalidXLogRecPtr)\n\t\tUpdateCheckPointDistanceEstimate(RedoRecPtr - PriorRedoPtr);\n\n\t/*\n\t * Delete old log files, those no longer needed for last restartpoint to\n\t * prevent the disk holding the xlog from growing full.\n\t */\n\tXLByteToSeg(RedoRecPtr, _logSegNo, wal_segment_size);\n\n\t/*\n\t * Retreat _logSegNo using the current end of xlog replayed or received,\n\t * whichever is later.\n\t */\n\treceivePtr = GetWalRcvFlushRecPtr(NULL, NULL);\n\treplayPtr = GetXLogReplayRecPtr(&replayTLI);\n\tendptr = (receivePtr < replayPtr) ? replayPtr : receivePtr;\n\tKeepLogSeg(endptr, &_logSegNo);\n\tif (InvalidateObsoleteReplicationSlots(RS_INVAL_WAL_REMOVED,\n\t\t\t\t\t\t\t\t\t\t   _logSegNo, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t   InvalidTransactionId))\n\t{\n\t\t/*\n\t\t * Some slots have been invalidated; recalculate the old-segment\n\t\t * horizon, starting again from RedoRecPtr.\n\t\t */\n\t\tXLByteToSeg(RedoRecPtr, _logSegNo, wal_segment_size);\n\t\tKeepLogSeg(endptr, &_logSegNo);\n\t}\n\t_logSegNo--;\n\n\t/*\n\t * Try to recycle segments on a useful timeline. If we've been promoted\n\t * since the beginning of this restartpoint, use the new timeline chosen\n\t * at end of recovery.  If we're still in recovery, use the timeline we're\n\t * currently replaying.\n\t *\n\t * There is no guarantee that the WAL segments will be useful on the\n\t * current timeline; if recovery proceeds to a new timeline right after\n\t * this, the pre-allocated WAL segments on this timeline will not be used,\n\t * and will go wasted until recycled on the next restartpoint. We'll live\n\t * with that.\n\t */\n\tif (!RecoveryInProgress())\n\t\treplayTLI = XLogCtl->InsertTimeLineID;\n\n\tRemoveOldXlogFiles(_logSegNo, RedoRecPtr, endptr, replayTLI);\n\n\t/*\n\t * Make more log segments if needed.  (Do this after recycling old log\n\t * segments, since that may supply some of the needed files.)\n\t */\n\tPreallocXlogFiles(endptr, replayTLI);\n\n\t/*\n\t * Truncate pg_subtrans if possible.  We can throw away all data before\n\t * the oldest XMIN of any running transaction.  No future transaction will\n\t * attempt to reference any pg_subtrans entry older than that (see Asserts\n\t * in subtrans.c).  When hot standby is disabled, though, we mustn't do\n\t * this because StartupSUBTRANS hasn't been called yet.\n\t */\n\tif (EnableHotStandby)\n\t\tTruncateSUBTRANS(GetOldestTransactionIdConsideredRunning());\n\n\t/* Real work is done; log and update stats. */\n\tLogCheckpointEnd(true);\n\n\t/* Reset the process title */\n\tupdate_checkpoint_display(flags, true, true);\n\n\txtime = GetLatestXTime();\n\tereport((log_checkpoints ? LOG : DEBUG2),\n\t\t\t(errmsg(\"recovery restart point at %X/%X\",\n\t\t\t\t\tLSN_FORMAT_ARGS(lastCheckPoint.redo)),\n\t\t\t xtime ? errdetail(\"Last completed transaction was at log time %s.\",\n\t\t\t\t\t\t\t   timestamptz_to_str(xtime)) : 0));\n\n\t/*\n\t * Finally, execute archive_cleanup_command, if any.\n\t */\n\tif (archiveCleanupCommand && strcmp(archiveCleanupCommand, \"\") != 0)\n\t\tExecuteRecoveryCommand(archiveCleanupCommand,\n\t\t\t\t\t\t\t   \"archive_cleanup_command\",\n\t\t\t\t\t\t\t   false,\n\t\t\t\t\t\t\t   WAIT_EVENT_ARCHIVE_CLEANUP_COMMAND);\n\n\treturn true;\n}ReplicationSlotCreate(const char *name, bool db_specific,\n\t\t\t\t\t  ReplicationSlotPersistency persistency, bool two_phase)\n{\n\tReplicationSlot *slot = NULL;\n\tint\t\t\ti;\n\n\tAssert(MyReplicationSlot == NULL);\n\n\tReplicationSlotValidateName(name, ERROR);\n\n\t/*\n\t * If some other backend ran this code concurrently with us, we'd likely\n\t * both allocate the same slot, and that would be bad.  We'd also be at\n\t * risk of missing a name collision.  Also, we don't want to try to create\n\t * a new slot while somebody's busy cleaning up an old one, because we\n\t * might both be monkeying with the same directory.\n\t */\n\tLWLockAcquire(ReplicationSlotAllocationLock, LW_EXCLUSIVE);\n\n\t/*\n\t * Check for name collision, and identify an allocatable slot.  We need to\n\t * hold ReplicationSlotControlLock in shared mode for this, so that nobody\n\t * else can change the in_use flags while we're looking at them.\n\t */\n\tLWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\n\tfor (i = 0; i < max_replication_slots; i++)\n\t{\n\t\tReplicationSlot *s = &ReplicationSlotCtl->replication_slots[i];\n\n\t\tif (s->in_use && strcmp(name, NameStr(s->data.name)) == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_OBJECT),\n\t\t\t\t\t errmsg(\"replication slot \\\"%s\\\" already exists\", name)));\n\t\tif (!s->in_use && slot == NULL)\n\t\t\tslot = s;\n\t}\n\tLWLockRelease(ReplicationSlotControlLock);\n\n\t/* If all slots are in use, we're out of luck. */\n\tif (slot == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"all replication slots are in use\"),\n\t\t\t\t errhint(\"Free one or increase max_replication_slots.\")));\n\n\t/*\n\t * Since this slot is not in use, nobody should be looking at any part of\n\t * it other than the in_use field unless they're trying to allocate it.\n\t * And since we hold ReplicationSlotAllocationLock, nobody except us can\n\t * be doing that.  So it's safe to initialize the slot.\n\t */\n\tAssert(!slot->in_use);\n\tAssert(slot->active_pid == 0);\n\n\t/* first initialize persistent data */\n\tmemset(&slot->data, 0, sizeof(ReplicationSlotPersistentData));\n\tnamestrcpy(&slot->data.name, name);\n\tslot->data.database = db_specific ? MyDatabaseId : InvalidOid;\n\tslot->data.persistency = persistency;\n\tslot->data.two_phase = two_phase;\n\tslot->data.two_phase_at = InvalidXLogRecPtr;\n\n\t/* and then data only present in shared memory */\n\tslot->just_dirtied = false;\n\tslot->dirty = false;\n\tslot->effective_xmin = InvalidTransactionId;\n\tslot->effective_catalog_xmin = InvalidTransactionId;\n\tslot->candidate_catalog_xmin = InvalidTransactionId;\n\tslot->candidate_xmin_lsn = InvalidXLogRecPtr;\n\tslot->candidate_restart_valid = InvalidXLogRecPtr;\n\tslot->candidate_restart_lsn = InvalidXLogRecPtr;\n\n\t/*\n\t * Create the slot on disk.  We haven't actually marked the slot allocated\n\t * yet, so no special cleanup is required if this errors out.\n\t */\n\tCreateSlotOnDisk(slot);\n\n\t/*\n\t * We need to briefly prevent any other backend from iterating over the\n\t * slots while we flip the in_use flag. We also need to set the active\n\t * flag while holding the ControlLock as otherwise a concurrent\n\t * ReplicationSlotAcquire() could acquire the slot as well.\n\t */\n\tLWLockAcquire(ReplicationSlotControlLock, LW_EXCLUSIVE);\n\n\tslot->in_use = true;\n\n\t/* We can now mark the slot active, and that makes it our slot. */\n\tSpinLockAcquire(&slot->mutex);\n\tAssert(slot->active_pid == 0);\n\tslot->active_pid = MyProcPid;\n\tSpinLockRelease(&slot->mutex);\n\tMyReplicationSlot = slot;\n\n\tLWLockRelease(ReplicationSlotControlLock);\n\n\t/*\n\t * Create statistics entry for the new logical slot. We don't collect any\n\t * stats for physical slots, so no need to create an entry for the same.\n\t * See ReplicationSlotDropPtr for why we need to do this before releasing\n\t * ReplicationSlotAllocationLock.\n\t */\n\tif (SlotIsLogical(slot))\n\t\tpgstat_create_replslot(slot);\n\n\t/*\n\t * Now that the slot has been marked as in_use and active, it's safe to\n\t * let somebody else try to allocate a slot.\n\t */\n\tLWLockRelease(ReplicationSlotAllocationLock);\n\n\t/* Let everybody know we've modified this slot */\n\tConditionVariableBroadcast(&slot->active_cv);\n}SearchNamedReplicationSlot(const char *name, bool need_lock)\n{\n\tint\t\t\ti;\n\tReplicationSlot *slot = NULL;\n\n\tif (need_lock)\n\t\tLWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\n\n\tfor (i = 0; i < max_replication_slots; i++)\n\t{\n\t\tReplicationSlot *s = &ReplicationSlotCtl->replication_slots[i];\n\n\t\tif (s->in_use && strcmp(name, NameStr(s->data.name)) == 0)\n\t\t{\n\t\t\tslot = s;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (need_lock)\n\t\tLWLockRelease(ReplicationSlotControlLock);\n\n\treturn slot;\n}copy_replication_slot(FunctionCallInfo fcinfo, bool logical_slot)\n{\n\tName\t\tsrc_name = PG_GETARG_NAME(0);\n\tName\t\tdst_name = PG_GETARG_NAME(1);\n\tReplicationSlot *src = NULL;\n\tReplicationSlot first_slot_contents;\n\tReplicationSlot second_slot_contents;\n\tXLogRecPtr\tsrc_restart_lsn;\n\tbool\t\tsrc_islogical;\n\tbool\t\ttemporary;\n\tchar\t   *plugin;\n\tDatum\t\tvalues[2];\n\tbool\t\tnulls[2];\n\tDatum\t\tresult;\n\tTupleDesc\ttupdesc;\n\tHeapTuple\ttuple;\n\n\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\telog(ERROR, \"return type must be a row type\");\n\n\tCheckSlotPermissions();\n\n\tif (logical_slot)\n\t\tCheckLogicalDecodingRequirements();\n\telse\n\t\tCheckSlotRequirements();\n\n\tLWLockAcquire(ReplicationSlotControlLock, LW_SHARED);\n\n\t/*\n\t * We need to prevent the source slot's reserved WAL from being removed,\n\t * but we don't want to lock that slot for very long, and it can advance\n\t * in the meantime.  So obtain the source slot's data, and create a new\n\t * slot using its restart_lsn.  Afterwards we lock the source slot again\n\t * and verify that the data we copied (name, type) has not changed\n\t * incompatibly.  No inconvenient WAL removal can occur once the new slot\n\t * is created -- but since WAL removal could have occurred before we\n\t * managed to create the new slot, we advance the new slot's restart_lsn\n\t * to the source slot's updated restart_lsn the second time we lock it.\n\t */\n\tfor (int i = 0; i < max_replication_slots; i++)\n\t{\n\t\tReplicationSlot *s = &ReplicationSlotCtl->replication_slots[i];\n\n\t\tif (s->in_use && strcmp(NameStr(s->data.name), NameStr(*src_name)) == 0)\n\t\t{\n\t\t\t/* Copy the slot contents while holding spinlock */\n\t\t\tSpinLockAcquire(&s->mutex);\n\t\t\tfirst_slot_contents = *s;\n\t\t\tSpinLockRelease(&s->mutex);\n\t\t\tsrc = s;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tLWLockRelease(ReplicationSlotControlLock);\n\n\tif (src == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"replication slot \\\"%s\\\" does not exist\", NameStr(*src_name))));\n\n\tsrc_islogical = SlotIsLogical(&first_slot_contents);\n\tsrc_restart_lsn = first_slot_contents.data.restart_lsn;\n\ttemporary = (first_slot_contents.data.persistency == RS_TEMPORARY);\n\tplugin = logical_slot ? NameStr(first_slot_contents.data.plugin) : NULL;\n\n\t/* Check type of replication slot */\n\tif (src_islogical != logical_slot)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t src_islogical ?\n\t\t\t\t errmsg(\"cannot copy physical replication slot \\\"%s\\\" as a logical replication slot\",\n\t\t\t\t\t\tNameStr(*src_name)) :\n\t\t\t\t errmsg(\"cannot copy logical replication slot \\\"%s\\\" as a physical replication slot\",\n\t\t\t\t\t\tNameStr(*src_name))));\n\n\t/* Copying non-reserved slot doesn't make sense */\n\tif (XLogRecPtrIsInvalid(src_restart_lsn))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"cannot copy a replication slot that doesn't reserve WAL\")));\n\n\t/* Overwrite params from optional arguments */\n\tif (PG_NARGS() >= 3)\n\t\ttemporary = PG_GETARG_BOOL(2);\n\tif (PG_NARGS() >= 4)\n\t{\n\t\tAssert(logical_slot);\n\t\tplugin = NameStr(*(PG_GETARG_NAME(3)));\n\t}\n\n\t/* Create new slot and acquire it */\n\tif (logical_slot)\n\t{\n\t\t/*\n\t\t * We must not try to read WAL, since we haven't reserved it yet --\n\t\t * hence pass find_startpoint false.  confirmed_flush will be set\n\t\t * below, by copying from the source slot.\n\t\t */\n\t\tcreate_logical_replication_slot(NameStr(*dst_name),\n\t\t\t\t\t\t\t\t\t\tplugin,\n\t\t\t\t\t\t\t\t\t\ttemporary,\n\t\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t\tsrc_restart_lsn,\n\t\t\t\t\t\t\t\t\t\tfalse);\n\t}\n\telse\n\t\tcreate_physical_replication_slot(NameStr(*dst_name),\n\t\t\t\t\t\t\t\t\t\t true,\n\t\t\t\t\t\t\t\t\t\t temporary,\n\t\t\t\t\t\t\t\t\t\t src_restart_lsn);\n\n\t/*\n\t * Update the destination slot to current values of the source slot;\n\t * recheck that the source slot is still the one we saw previously.\n\t */\n\t{\n\t\tTransactionId copy_effective_xmin;\n\t\tTransactionId copy_effective_catalog_xmin;\n\t\tTransactionId copy_xmin;\n\t\tTransactionId copy_catalog_xmin;\n\t\tXLogRecPtr\tcopy_restart_lsn;\n\t\tXLogRecPtr\tcopy_confirmed_flush;\n\t\tbool\t\tcopy_islogical;\n\t\tchar\t   *copy_name;\n\n\t\t/* Copy data of source slot again */\n\t\tSpinLockAcquire(&src->mutex);\n\t\tsecond_slot_contents = *src;\n\t\tSpinLockRelease(&src->mutex);\n\n\t\tcopy_effective_xmin = second_slot_contents.effective_xmin;\n\t\tcopy_effective_catalog_xmin = second_slot_contents.effective_catalog_xmin;\n\n\t\tcopy_xmin = second_slot_contents.data.xmin;\n\t\tcopy_catalog_xmin = second_slot_contents.data.catalog_xmin;\n\t\tcopy_restart_lsn = second_slot_contents.data.restart_lsn;\n\t\tcopy_confirmed_flush = second_slot_contents.data.confirmed_flush;\n\n\t\t/* for existence check */\n\t\tcopy_name = NameStr(second_slot_contents.data.name);\n\t\tcopy_islogical = SlotIsLogical(&second_slot_contents);\n\n\t\t/*\n\t\t * Check if the source slot still exists and is valid. We regard it as\n\t\t * invalid if the type of replication slot or name has been changed,\n\t\t * or the restart_lsn either is invalid or has gone backward. (The\n\t\t * restart_lsn could go backwards if the source slot is dropped and\n\t\t * copied from an older slot during installation.)\n\t\t *\n\t\t * Since erroring out will release and drop the destination slot we\n\t\t * don't need to release it here.\n\t\t */\n\t\tif (copy_restart_lsn < src_restart_lsn ||\n\t\t\tsrc_islogical != copy_islogical ||\n\t\t\tstrcmp(copy_name, NameStr(*src_name)) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not copy replication slot \\\"%s\\\"\",\n\t\t\t\t\t\t\tNameStr(*src_name)),\n\t\t\t\t\t errdetail(\"The source replication slot was modified incompatibly during the copy operation.\")));\n\n\t\t/* The source slot must have a consistent snapshot */\n\t\tif (src_islogical && XLogRecPtrIsInvalid(copy_confirmed_flush))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot copy unfinished logical replication slot \\\"%s\\\"\",\n\t\t\t\t\t\t\tNameStr(*src_name)),\n\t\t\t\t\t errhint(\"Retry when the source replication slot's confirmed_flush_lsn is valid.\")));\n\n\t\t/* Install copied values again */\n\t\tSpinLockAcquire(&MyReplicationSlot->mutex);\n\t\tMyReplicationSlot->effective_xmin = copy_effective_xmin;\n\t\tMyReplicationSlot->effective_catalog_xmin = copy_effective_catalog_xmin;\n\n\t\tMyReplicationSlot->data.xmin = copy_xmin;\n\t\tMyReplicationSlot->data.catalog_xmin = copy_catalog_xmin;\n\t\tMyReplicationSlot->data.restart_lsn = copy_restart_lsn;\n\t\tMyReplicationSlot->data.confirmed_flush = copy_confirmed_flush;\n\t\tSpinLockRelease(&MyReplicationSlot->mutex);\n\n\t\tReplicationSlotMarkDirty();\n\t\tReplicationSlotsComputeRequiredXmin(false);\n\t\tReplicationSlotsComputeRequiredLSN();\n\t\tReplicationSlotSave();\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Check that the restart_lsn is available */\n\t\t{\n\t\t\tXLogSegNo\tsegno;\n\n\t\t\tXLByteToSeg(copy_restart_lsn, segno, wal_segment_size);\n\t\t\tAssert(XLogGetLastRemovedSegno() < segno);\n\t\t}\n#endif\n\t}\n\n\t/* target slot fully created, mark as persistent if needed */\n\tif (logical_slot && !temporary)\n\t\tReplicationSlotPersist();\n\n\t/* All done.  Set up the return values */\n\tvalues[0] = NameGetDatum(dst_name);\n\tnulls[0] = false;\n\tif (!XLogRecPtrIsInvalid(MyReplicationSlot->data.confirmed_flush))\n\t{\n\t\tvalues[1] = LSNGetDatum(MyReplicationSlot->data.confirmed_flush);\n\t\tnulls[1] = false;\n\t}\n\telse\n\t\tnulls[1] = true;\n\n\ttuple = heap_form_tuple(tupdesc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tReplicationSlotRelease();\n\n\tPG_RETURN_DATUM(result);\n}PostmasterMain(int argc, char *argv[])\n{\n\tint\t\t\topt;\n\tint\t\t\tstatus;\n\tchar\t   *userDoption = NULL;\n\tbool\t\tlisten_addr_saved = false;\n\tint\t\t\ti;\n\tchar\t   *output_config_variable = NULL;\n\n\tInitProcessGlobals();\n\n\tPostmasterPid = MyProcPid;\n\n\tIsPostmasterEnvironment = true;\n\n\t/*\n\t * Start our win32 signal implementation\n\t */\n#ifdef WIN32\n\tpgwin32_signal_initialize();\n#endif\n\n\t/*\n\t * We should not be creating any files or directories before we check the\n\t * data directory (see checkDataDir()), but just in case set the umask to\n\t * the most restrictive (owner-only) permissions.\n\t *\n\t * checkDataDir() will reset the umask based on the data directory\n\t * permissions.\n\t */\n\tumask(PG_MODE_MASK_OWNER);\n\n\t/*\n\t * By default, palloc() requests in the postmaster will be allocated in\n\t * the PostmasterContext, which is space that can be recycled by backends.\n\t * Allocated data that needs to be available to backends should be\n\t * allocated in TopMemoryContext.\n\t */\n\tPostmasterContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"Postmaster\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\tMemoryContextSwitchTo(PostmasterContext);\n\n\t/* Initialize paths to installation files */\n\tgetInstallationPaths(argv[0]);\n\n\t/*\n\t * Set up signal handlers for the postmaster process.\n\t *\n\t * CAUTION: when changing this list, check for side-effects on the signal\n\t * handling setup of child processes.  See tcop/postgres.c,\n\t * bootstrap/bootstrap.c, postmaster/bgwriter.c, postmaster/walwriter.c,\n\t * postmaster/autovacuum.c, postmaster/pgarch.c, postmaster/syslogger.c,\n\t * postmaster/bgworker.c and postmaster/checkpointer.c.\n\t */\n\tpqinitmask();\n\tsigprocmask(SIG_SETMASK, &BlockSig, NULL);\n\n\tpqsignal(SIGHUP, handle_pm_reload_request_signal);\n\tpqsignal(SIGINT, handle_pm_shutdown_request_signal);\n\tpqsignal(SIGQUIT, handle_pm_shutdown_request_signal);\n\tpqsignal(SIGTERM, handle_pm_shutdown_request_signal);\n\tpqsignal(SIGALRM, SIG_IGN); /* ignored */\n\tpqsignal(SIGPIPE, SIG_IGN); /* ignored */\n\tpqsignal(SIGUSR1, handle_pm_pmsignal_signal);\n\tpqsignal(SIGUSR2, dummy_handler);\t/* unused, reserve for children */\n\tpqsignal(SIGCHLD, handle_pm_child_exit_signal);\n\n\t/* This may configure SIGURG, depending on platform. */\n\tInitializeLatchSupport();\n\tInitProcessLocalLatch();\n\n\t/*\n\t * No other place in Postgres should touch SIGTTIN/SIGTTOU handling.  We\n\t * ignore those signals in a postmaster environment, so that there is no\n\t * risk of a child process freezing up due to writing to stderr.  But for\n\t * a standalone backend, their default handling is reasonable.  Hence, all\n\t * child processes should just allow the inherited settings to stand.\n\t */\n#ifdef SIGTTIN\n\tpqsignal(SIGTTIN, SIG_IGN); /* ignored */\n#endif\n#ifdef SIGTTOU\n\tpqsignal(SIGTTOU, SIG_IGN); /* ignored */\n#endif\n\n\t/* ignore SIGXFSZ, so that ulimit violations work like disk full */\n#ifdef SIGXFSZ\n\tpqsignal(SIGXFSZ, SIG_IGN); /* ignored */\n#endif\n\n\t/* Begin accepting signals. */\n\tsigprocmask(SIG_SETMASK, &UnBlockSig, NULL);\n\n\t/*\n\t * Options setup\n\t */\n\tInitializeGUCOptions();\n\n\topterr = 1;\n\n\t/*\n\t * Parse command-line options.  CAUTION: keep this in sync with\n\t * tcop/postgres.c (the option sets should not conflict) and with the\n\t * common help() function in main/main.c.\n\t */\n\twhile ((opt = getopt(argc, argv, \"B:bC:c:D:d:EeFf:h:ijk:lN:OPp:r:S:sTt:W:-:\")) != -1)\n\t{\n\t\tswitch (opt)\n\t\t{\n\t\t\tcase 'B':\n\t\t\t\tSetConfigOption(\"shared_buffers\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'b':\n\t\t\t\t/* Undocumented flag used for binary upgrades */\n\t\t\t\tIsBinaryUpgrade = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'C':\n\t\t\t\toutput_config_variable = strdup(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':\n\t\t\tcase '-':\n\t\t\t\t{\n\t\t\t\t\tchar\t   *name,\n\t\t\t\t\t\t\t   *value;\n\n\t\t\t\t\tParseLongOption(optarg, &name, &value);\n\t\t\t\t\tif (!value)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (opt == '-')\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t\t errmsg(\"--%s requires a value\",\n\t\t\t\t\t\t\t\t\t\t\toptarg)));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t\t errmsg(\"-c %s requires a value\",\n\t\t\t\t\t\t\t\t\t\t\toptarg)));\n\t\t\t\t\t}\n\n\t\t\t\t\tSetConfigOption(name, value, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\t\tpfree(name);\n\t\t\t\t\tpfree(value);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 'D':\n\t\t\t\tuserDoption = strdup(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'd':\n\t\t\t\tset_debug_options(atoi(optarg), PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\tSetConfigOption(\"log_statement\", \"all\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'e':\n\t\t\t\tSetConfigOption(\"datestyle\", \"euro\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'F':\n\t\t\t\tSetConfigOption(\"fsync\", \"false\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\tif (!set_plan_disabling_options(optarg, PGC_POSTMASTER, PGC_S_ARGV))\n\t\t\t\t{\n\t\t\t\t\twrite_stderr(\"%s: invalid argument for option -f: \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\t progname, optarg);\n\t\t\t\t\tExitPostmaster(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\t\tSetConfigOption(\"listen_addresses\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'i':\n\t\t\t\tSetConfigOption(\"listen_addresses\", \"*\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'j':\n\t\t\t\t/* only used by interactive backend */\n\t\t\t\tbreak;\n\n\t\t\tcase 'k':\n\t\t\t\tSetConfigOption(\"unix_socket_directories\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\t\tSetConfigOption(\"ssl\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'N':\n\t\t\t\tSetConfigOption(\"max_connections\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'O':\n\t\t\t\tSetConfigOption(\"allow_system_table_mods\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':\n\t\t\t\tSetConfigOption(\"ignore_system_indexes\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\tSetConfigOption(\"port\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\n\t\t\t\t/* only used by single-user backend */\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\tSetConfigOption(\"work_mem\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tSetConfigOption(\"log_statement_stats\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'T':\n\n\t\t\t\t/*\n\t\t\t\t * This option used to be defined as sending SIGSTOP after a\n\t\t\t\t * backend crash, but sending SIGABRT seems more useful.\n\t\t\t\t */\n\t\t\t\tSetConfigOption(\"send_abort_for_crash\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\t{\n\t\t\t\t\tconst char *tmp = get_stats_option_name(optarg);\n\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tSetConfigOption(tmp, \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twrite_stderr(\"%s: invalid argument for option -t: \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\t\t progname, optarg);\n\t\t\t\t\t\tExitPostmaster(1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 'W':\n\t\t\t\tSetConfigOption(\"post_auth_delay\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\twrite_stderr(\"Try \\\"%s --help\\\" for more information.\\n\",\n\t\t\t\t\t\t\t progname);\n\t\t\t\tExitPostmaster(1);\n\t\t}\n\t}\n\n\t/*\n\t * Postmaster accepts no non-option switch arguments.\n\t */\n\tif (optind < argc)\n\t{\n\t\twrite_stderr(\"%s: invalid argument: \\\"%s\\\"\\n\",\n\t\t\t\t\t progname, argv[optind]);\n\t\twrite_stderr(\"Try \\\"%s --help\\\" for more information.\\n\",\n\t\t\t\t\t progname);\n\t\tExitPostmaster(1);\n\t}\n\n\t/*\n\t * Locate the proper configuration files and data directory, and read\n\t * postgresql.conf for the first time.\n\t */\n\tif (!SelectConfigFiles(userDoption, progname))\n\t\tExitPostmaster(2);\n\n\tif (output_config_variable != NULL)\n\t{\n\t\t/*\n\t\t * If this is a runtime-computed GUC, it hasn't yet been initialized,\n\t\t * and the present value is not useful.  However, this is a convenient\n\t\t * place to print the value for most GUCs because it is safe to run\n\t\t * postmaster startup to this point even if the server is already\n\t\t * running.  For the handful of runtime-computed GUCs that we cannot\n\t\t * provide meaningful values for yet, we wait until later in\n\t\t * postmaster startup to print the value.  We won't be able to use -C\n\t\t * on running servers for those GUCs, but using this option now would\n\t\t * lead to incorrect results for them.\n\t\t */\n\t\tint\t\t\tflags = GetConfigOptionFlags(output_config_variable, true);\n\n\t\tif ((flags & GUC_RUNTIME_COMPUTED) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * \"-C guc\" was specified, so print GUC's value and exit.  No\n\t\t\t * extra permission check is needed because the user is reading\n\t\t\t * inside the data dir.\n\t\t\t */\n\t\t\tconst char *config_val = GetConfigOption(output_config_variable,\n\t\t\t\t\t\t\t\t\t\t\t\t\t false, false);\n\n\t\t\tputs(config_val ? config_val : \"\");\n\t\t\tExitPostmaster(0);\n\t\t}\n\n\t\t/*\n\t\t * A runtime-computed GUC will be printed later on.  As we initialize\n\t\t * a server startup sequence, silence any log messages that may show\n\t\t * up in the output generated.  FATAL and more severe messages are\n\t\t * useful to show, even if one would only expect at least PANIC.  LOG\n\t\t * entries are hidden.\n\t\t */\n\t\tSetConfigOption(\"log_min_messages\", \"FATAL\", PGC_SUSET,\n\t\t\t\t\t\tPGC_S_OVERRIDE);\n\t}\n\n\t/* Verify that DataDir looks reasonable */\n\tcheckDataDir();\n\n\t/* Check that pg_control exists */\n\tcheckControlFile();\n\n\t/* And switch working directory into it */\n\tChangeToDataDir();\n\n\t/*\n\t * Check for invalid combinations of GUC settings.\n\t */\n\tif (SuperuserReservedConnections + ReservedConnections >= MaxConnections)\n\t{\n\t\twrite_stderr(\"%s: superuser_reserved_connections (%d) plus reserved_connections (%d) must be less than max_connections (%d)\\n\",\n\t\t\t\t\t progname,\n\t\t\t\t\t SuperuserReservedConnections, ReservedConnections,\n\t\t\t\t\t MaxConnections);\n\t\tExitPostmaster(1);\n\t}\n\tif (XLogArchiveMode > ARCHIVE_MODE_OFF && wal_level == WAL_LEVEL_MINIMAL)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"WAL archival cannot be enabled when wal_level is \\\"minimal\\\"\")));\n\tif (max_wal_senders > 0 && wal_level == WAL_LEVEL_MINIMAL)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"WAL streaming (max_wal_senders > 0) requires wal_level \\\"replica\\\" or \\\"logical\\\"\")));\n\n\t/*\n\t * Other one-time internal sanity checks can go here, if they are fast.\n\t * (Put any slow processing further down, after postmaster.pid creation.)\n\t */\n\tif (!CheckDateTokenTables())\n\t{\n\t\twrite_stderr(\"%s: invalid datetoken tables, please fix\\n\", progname);\n\t\tExitPostmaster(1);\n\t}\n\n\t/*\n\t * Now that we are done processing the postmaster arguments, reset\n\t * getopt(3) library so that it will work correctly in subprocesses.\n\t */\n\toptind = 1;\n#ifdef HAVE_INT_OPTRESET\n\toptreset = 1;\t\t\t\t/* some systems need this too */\n#endif\n\n\t/* For debugging: display postmaster environment */\n\t{\n\t\textern char **environ;\n\t\tchar\t  **p;\n\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"%s: PostmasterMain: initial environment dump:\",\n\t\t\t\t\t\t\t\t progname)));\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"-----------------------------------------\")));\n\t\tfor (p = environ; *p; ++p)\n\t\t\tereport(DEBUG3,\n\t\t\t\t\t(errmsg_internal(\"\\t%s\", *p)));\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"-----------------------------------------\")));\n\t}\n\n\t/*\n\t * Create lockfile for data directory.\n\t *\n\t * We want to do this before we try to grab the input sockets, because the\n\t * data directory interlock is more reliable than the socket-file\n\t * interlock (thanks to whoever decided to put socket files in /tmp :-().\n\t * For the same reason, it's best to grab the TCP socket(s) before the\n\t * Unix socket(s).\n\t *\n\t * Also note that this internally sets up the on_proc_exit function that\n\t * is responsible for removing both data directory and socket lockfiles;\n\t * so it must happen before opening sockets so that at exit, the socket\n\t * lockfiles go away after CloseServerPorts runs.\n\t */\n\tCreateDataDirLockFile(true);\n\n\t/*\n\t * Read the control file (for error checking and config info).\n\t *\n\t * Since we verify the control file's CRC, this has a useful side effect\n\t * on machines where we need a run-time test for CRC support instructions.\n\t * The postmaster will do the test once at startup, and then its child\n\t * processes will inherit the correct function pointer and not need to\n\t * repeat the test.\n\t */\n\tLocalProcessControlFile(false);\n\n\t/*\n\t * Register the apply launcher.  It's probably a good idea to call this\n\t * before any modules had a chance to take the background worker slots.\n\t */\n\tApplyLauncherRegister();\n\n\t/*\n\t * process any libraries that should be preloaded at postmaster start\n\t */\n\tprocess_shared_preload_libraries();\n\n\t/*\n\t * Initialize SSL library, if specified.\n\t */\n#ifdef USE_SSL\n\tif (EnableSSL)\n\t{\n\t\t(void) secure_initialize(true);\n\t\tLoadedSSL = true;\n\t}\n#endif\n\n\t/*\n\t * Now that loadable modules have had their chance to alter any GUCs,\n\t * calculate MaxBackends.\n\t */\n\tInitializeMaxBackends();\n\n\t/*\n\t * Give preloaded libraries a chance to request additional shared memory.\n\t */\n\tprocess_shmem_requests();\n\n\t/*\n\t * Now that loadable modules have had their chance to request additional\n\t * shared memory, determine the value of any runtime-computed GUCs that\n\t * depend on the amount of shared memory required.\n\t */\n\tInitializeShmemGUCs();\n\n\t/*\n\t * Now that modules have been loaded, we can process any custom resource\n\t * managers specified in the wal_consistency_checking GUC.\n\t */\n\tInitializeWalConsistencyChecking();\n\n\t/*\n\t * If -C was specified with a runtime-computed GUC, we held off printing\n\t * the value earlier, as the GUC was not yet initialized.  We handle -C\n\t * for most GUCs before we lock the data directory so that the option may\n\t * be used on a running server.  However, a handful of GUCs are runtime-\n\t * computed and do not have meaningful values until after locking the data\n\t * directory, and we cannot safely calculate their values earlier on a\n\t * running server.  At this point, such GUCs should be properly\n\t * initialized, and we haven't yet set up shared memory, so this is a good\n\t * time to handle the -C option for these special GUCs.\n\t */\n\tif (output_config_variable != NULL)\n\t{\n\t\tconst char *config_val = GetConfigOption(output_config_variable,\n\t\t\t\t\t\t\t\t\t\t\t\t false, false);\n\n\t\tputs(config_val ? config_val : \"\");\n\t\tExitPostmaster(0);\n\t}\n\n\t/*\n\t * Set up shared memory and semaphores.\n\t *\n\t * Note: if using SysV shmem and/or semas, each postmaster startup will\n\t * normally choose the same IPC keys.  This helps ensure that we will\n\t * clean up dead IPC objects if the postmaster crashes and is restarted.\n\t */\n\tCreateSharedMemoryAndSemaphores();\n\n\t/*\n\t * Estimate number of openable files.  This must happen after setting up\n\t * semaphores, because on some platforms semaphores count as open files.\n\t */\n\tset_max_safe_fds();\n\n\t/*\n\t * Set reference point for stack-depth checking.\n\t */\n\t(void) set_stack_base();\n\n\t/*\n\t * Initialize pipe (or process handle on Windows) that allows children to\n\t * wake up from sleep on postmaster death.\n\t */\n\tInitPostmasterDeathWatchHandle();\n\n#ifdef WIN32\n\n\t/*\n\t * Initialize I/O completion port used to deliver list of dead children.\n\t */\n\twin32ChildQueue = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);\n\tif (win32ChildQueue == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"could not create I/O completion port for child queue\")));\n#endif\n\n#ifdef EXEC_BACKEND\n\t/* Write out nondefault GUC settings for child processes to use */\n\twrite_nondefault_variables(PGC_POSTMASTER);\n\n\t/*\n\t * Clean out the temp directory used to transmit parameters to child\n\t * processes (see internal_forkexec, below).  We must do this before\n\t * launching any child processes, else we have a race condition: we could\n\t * remove a parameter file before the child can read it.  It should be\n\t * safe to do so now, because we verified earlier that there are no\n\t * conflicting Postgres processes in this data directory.\n\t */\n\tRemovePgTempFilesInDir(PG_TEMP_FILES_DIR, true, false);\n#endif\n\n\t/*\n\t * Forcibly remove the files signaling a standby promotion request.\n\t * Otherwise, the existence of those files triggers a promotion too early,\n\t * whether a user wants that or not.\n\t *\n\t * This removal of files is usually unnecessary because they can exist\n\t * only during a few moments during a standby promotion. However there is\n\t * a race condition: if pg_ctl promote is executed and creates the files\n\t * during a promotion, the files can stay around even after the server is\n\t * brought up to be the primary.  Then, if a new standby starts by using\n\t * the backup taken from the new primary, the files can exist at server\n\t * startup and must be removed in order to avoid an unexpected promotion.\n\t *\n\t * Note that promotion signal files need to be removed before the startup\n\t * process is invoked. Because, after that, they can be used by\n\t * postmaster's SIGUSR1 signal handler.\n\t */\n\tRemovePromoteSignalFiles();\n\n\t/* Do the same for logrotate signal file */\n\tRemoveLogrotateSignalFiles();\n\n\t/* Remove any outdated file holding the current log filenames. */\n\tif (unlink(LOG_METAINFO_DATAFILE) < 0 && errno != ENOENT)\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\",\n\t\t\t\t\t\tLOG_METAINFO_DATAFILE)));\n\n\t/*\n\t * Initialize input sockets.\n\t *\n\t * Mark them all closed, and set up an on_proc_exit function that's\n\t * charged with closing the sockets again at postmaster shutdown.\n\t */\n\tfor (i = 0; i < MAXLISTEN; i++)\n\t\tListenSocket[i] = PGINVALID_SOCKET;\n\n\ton_proc_exit(CloseServerPorts, 0);\n\n\t/*\n\t * If enabled, start up syslogger collection subprocess\n\t */\n\tSysLoggerPID = SysLogger_Start();\n\n\t/*\n\t * Reset whereToSendOutput from DestDebug (its starting state) to\n\t * DestNone. This stops ereport from sending log messages to stderr unless\n\t * Log_destination permits.  We don't do this until the postmaster is\n\t * fully launched, since startup failures may as well be reported to\n\t * stderr.\n\t *\n\t * If we are in fact disabling logging to stderr, first emit a log message\n\t * saying so, to provide a breadcrumb trail for users who may not remember\n\t * that their logging is configured to go somewhere else.\n\t */\n\tif (!(Log_destination & LOG_DESTINATION_STDERR))\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"ending log output to stderr\"),\n\t\t\t\t errhint(\"Future log output will go to log destination \\\"%s\\\".\",\n\t\t\t\t\t\t Log_destination_string)));\n\n\twhereToSendOutput = DestNone;\n\n\t/*\n\t * Report server startup in log.  While we could emit this much earlier,\n\t * it seems best to do so after starting the log collector, if we intend\n\t * to use one.\n\t */\n\tereport(LOG,\n\t\t\t(errmsg(\"starting %s\", PG_VERSION_STR)));\n\n\t/*\n\t * Establish input sockets.\n\t */\n\tif (ListenAddresses)\n\t{\n\t\tchar\t   *rawstring;\n\t\tList\t   *elemlist;\n\t\tListCell   *l;\n\t\tint\t\t\tsuccess = 0;\n\n\t\t/* Need a modifiable copy of ListenAddresses */\n\t\trawstring = pstrdup(ListenAddresses);\n\n\t\t/* Parse string into list of hostnames */\n\t\tif (!SplitGUCList(rawstring, ',', &elemlist))\n\t\t{\n\t\t\t/* syntax error in list */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"listen_addresses\")));\n\t\t}\n\n\t\tforeach(l, elemlist)\n\t\t{\n\t\t\tchar\t   *curhost = (char *) lfirst(l);\n\n\t\t\tif (strcmp(curhost, \"*\") == 0)\n\t\t\t\tstatus = StreamServerPort(AF_UNSPEC, NULL,\n\t\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\t\t\telse\n\t\t\t\tstatus = StreamServerPort(AF_UNSPEC, curhost,\n\t\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\n\t\t\tif (status == STATUS_OK)\n\t\t\t{\n\t\t\t\tsuccess++;\n\t\t\t\t/* record the first successful host addr in lockfile */\n\t\t\t\tif (!listen_addr_saved)\n\t\t\t\t{\n\t\t\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_LISTEN_ADDR, curhost);\n\t\t\t\t\tlisten_addr_saved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"could not create listen socket for \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tcurhost)));\n\t\t}\n\n\t\tif (!success && elemlist != NIL)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errmsg(\"could not create any TCP/IP sockets\")));\n\n\t\tlist_free(elemlist);\n\t\tpfree(rawstring);\n\t}\n\n#ifdef USE_BONJOUR\n\t/* Register for Bonjour only if we opened TCP socket(s) */\n\tif (enable_bonjour && ListenSocket[0] != PGINVALID_SOCKET)\n\t{\n\t\tDNSServiceErrorType err;\n\n\t\t/*\n\t\t * We pass 0 for interface_index, which will result in registering on\n\t\t * all \"applicable\" interfaces.  It's not entirely clear from the\n\t\t * DNS-SD docs whether this would be appropriate if we have bound to\n\t\t * just a subset of the available network interfaces.\n\t\t */\n\t\terr = DNSServiceRegister(&bonjour_sdref,\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t bonjour_name,\n\t\t\t\t\t\t\t\t \"_postgresql._tcp.\",\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t pg_hton16(PostPortNumber),\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL);\n\t\tif (err != kDNSServiceErr_NoError)\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"DNSServiceRegister() failed: error code %ld\",\n\t\t\t\t\t\t\t(long) err)));\n\n\t\t/*\n\t\t * We don't bother to read the mDNS daemon's reply, and we expect that\n\t\t * it will automatically terminate our registration when the socket is\n\t\t * closed at postmaster termination.  So there's nothing more to be\n\t\t * done here.  However, the bonjour_sdref is kept around so that\n\t\t * forked children can close their copies of the socket.\n\t\t */\n\t}\n#endif\n\n\tif (Unix_socket_directories)\n\t{\n\t\tchar\t   *rawstring;\n\t\tList\t   *elemlist;\n\t\tListCell   *l;\n\t\tint\t\t\tsuccess = 0;\n\n\t\t/* Need a modifiable copy of Unix_socket_directories */\n\t\trawstring = pstrdup(Unix_socket_directories);\n\n\t\t/* Parse string into list of directories */\n\t\tif (!SplitDirectoriesString(rawstring, ',', &elemlist))\n\t\t{\n\t\t\t/* syntax error in list */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"unix_socket_directories\")));\n\t\t}\n\n\t\tforeach(l, elemlist)\n\t\t{\n\t\t\tchar\t   *socketdir = (char *) lfirst(l);\n\n\t\t\tstatus = StreamServerPort(AF_UNIX, NULL,\n\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t  socketdir,\n\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\n\t\t\tif (status == STATUS_OK)\n\t\t\t{\n\t\t\t\tsuccess++;\n\t\t\t\t/* record the first successful Unix socket in lockfile */\n\t\t\t\tif (success == 1)\n\t\t\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_SOCKET_DIR, socketdir);\n\t\t\t}\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"could not create Unix-domain socket in directory \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tsocketdir)));\n\t\t}\n\n\t\tif (!success && elemlist != NIL)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errmsg(\"could not create any Unix-domain sockets\")));\n\n\t\tlist_free_deep(elemlist);\n\t\tpfree(rawstring);\n\t}\n\n\t/*\n\t * check that we have some socket to listen on\n\t */\n\tif (ListenSocket[0] == PGINVALID_SOCKET)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"no socket created for listening\")));\n\n\t/*\n\t * If no valid TCP ports, write an empty line for listen address,\n\t * indicating the Unix socket must be used.  Note that this line is not\n\t * added to the lock file until there is a socket backing it.\n\t */\n\tif (!listen_addr_saved)\n\t\tAddToDataDirLockFile(LOCK_FILE_LINE_LISTEN_ADDR, \"\");\n\n\t/*\n\t * Record postmaster options.  We delay this till now to avoid recording\n\t * bogus options (eg, unusable port number).\n\t */\n\tif (!CreateOptsFile(argc, argv, my_exec_path))\n\t\tExitPostmaster(1);\n\n\t/*\n\t * Write the external PID file if requested\n\t */\n\tif (external_pid_file)\n\t{\n\t\tFILE\t   *fpidfile = fopen(external_pid_file, \"w\");\n\n\t\tif (fpidfile)\n\t\t{\n\t\t\tfprintf(fpidfile, \"%d\\n\", MyProcPid);\n\t\t\tfclose(fpidfile);\n\n\t\t\t/* Make PID file world readable */\n\t\t\tif (chmod(external_pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) != 0)\n\t\t\t\twrite_stderr(\"%s: could not change permissions of external PID file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t\t\t progname, external_pid_file, strerror(errno));\n\t\t}\n\t\telse\n\t\t\twrite_stderr(\"%s: could not write external PID file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t\t progname, external_pid_file, strerror(errno));\n\n\t\ton_proc_exit(unlink_external_pid_file, 0);\n\t}\n\n\t/*\n\t * Remove old temporary files.  At this point there can be no other\n\t * Postgres processes running in this directory, so this should be safe.\n\t */\n\tRemovePgTempFiles();\n\n\t/*\n\t * Initialize the autovacuum subsystem (again, no process start yet)\n\t */\n\tautovac_init();\n\n\t/*\n\t * Load configuration files for client authentication.\n\t */\n\tif (!load_hba())\n\t{\n\t\t/*\n\t\t * It makes no sense to continue if we fail to load the HBA file,\n\t\t * since there is no way to connect to the database in this case.\n\t\t */\n\t\tereport(FATAL,\n\t\t/* translator: %s is a configuration file */\n\t\t\t\t(errmsg(\"could not load %s\", HbaFileName)));\n\t}\n\tif (!load_ident())\n\t{\n\t\t/*\n\t\t * We can start up without the IDENT file, although it means that you\n\t\t * cannot log in using any of the authentication methods that need a\n\t\t * user name mapping. load_ident() already logged the details of error\n\t\t * to the log.\n\t\t */\n\t}\n\n#ifdef HAVE_PTHREAD_IS_THREADED_NP\n\n\t/*\n\t * On macOS, libintl replaces setlocale() with a version that calls\n\t * CFLocaleCopyCurrent() when its second argument is \"\" and every relevant\n\t * environment variable is unset or empty.  CFLocaleCopyCurrent() makes\n\t * the process multithreaded.  The postmaster calls sigprocmask() and\n\t * calls fork() without an immediate exec(), both of which have undefined\n\t * behavior in a multithreaded program.  A multithreaded postmaster is the\n\t * normal case on Windows, which offers neither fork() nor sigprocmask().\n\t */\n\tif (pthread_is_threaded_np() != 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"postmaster became multithreaded during startup\"),\n\t\t\t\t errhint(\"Set the LC_ALL environment variable to a valid locale.\")));\n#endif\n\n\t/*\n\t * Remember postmaster startup time\n\t */\n\tPgStartTime = GetCurrentTimestamp();\n\n\t/*\n\t * Report postmaster status in the postmaster.pid file, to allow pg_ctl to\n\t * see what's happening.\n\t */\n\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STARTING);\n\n\t/* Start bgwriter and checkpointer so they can help with recovery */\n\tif (CheckpointerPID == 0)\n\t\tCheckpointerPID = StartCheckpointer();\n\tif (BgWriterPID == 0)\n\t\tBgWriterPID = StartBackgroundWriter();\n\n\t/*\n\t * We're ready to rock and roll...\n\t */\n\tStartupPID = StartupDataBase();\n\tAssert(StartupPID != 0);\n\tStartupStatus = STARTUP_RUNNING;\n\tpmState = PM_STARTUP;\n\n\t/* Some workers may be scheduled to start now */\n\tmaybe_start_bgworkers();\n\n\tstatus = ServerLoop();\n\n\t/*\n\t * ServerLoop probably shouldn't ever return, but if it does, close down.\n\t */\n\tExitPostmaster(status != STATUS_OK);\n\n\tabort();\t\t\t\t\t/* not reached */\n}WalReceiverMain(void)\n{\n\tchar\t\tconninfo[MAXCONNINFO];\n\tchar\t   *tmp_conninfo;\n\tchar\t\tslotname[NAMEDATALEN];\n\tbool\t\tis_temp_slot;\n\tXLogRecPtr\tstartpoint;\n\tTimeLineID\tstartpointTLI;\n\tTimeLineID\tprimaryTLI;\n\tbool\t\tfirst_stream;\n\tWalRcvData *walrcv = WalRcv;\n\tTimestampTz now;\n\tchar\t   *err;\n\tchar\t   *sender_host = NULL;\n\tint\t\t\tsender_port = 0;\n\n\t/*\n\t * WalRcv should be set up already (if we are a backend, we inherit this\n\t * by fork() or EXEC_BACKEND mechanism from the postmaster).\n\t */\n\tAssert(walrcv != NULL);\n\n\t/*\n\t * Mark walreceiver as running in shared memory.\n\t *\n\t * Do this as early as possible, so that if we fail later on, we'll set\n\t * state to STOPPED. If we die before this, the startup process will keep\n\t * waiting for us to start up, until it times out.\n\t */\n\tSpinLockAcquire(&walrcv->mutex);\n\tAssert(walrcv->pid == 0);\n\tswitch (walrcv->walRcvState)\n\t{\n\t\tcase WALRCV_STOPPING:\n\t\t\t/* If we've already been requested to stop, don't start up. */\n\t\t\twalrcv->walRcvState = WALRCV_STOPPED;\n\t\t\t/* fall through */\n\n\t\tcase WALRCV_STOPPED:\n\t\t\tSpinLockRelease(&walrcv->mutex);\n\t\t\tConditionVariableBroadcast(&walrcv->walRcvStoppedCV);\n\t\t\tproc_exit(1);\n\t\t\tbreak;\n\n\t\tcase WALRCV_STARTING:\n\t\t\t/* The usual case */\n\t\t\tbreak;\n\n\t\tcase WALRCV_WAITING:\n\t\tcase WALRCV_STREAMING:\n\t\tcase WALRCV_RESTARTING:\n\t\tdefault:\n\t\t\t/* Shouldn't happen */\n\t\t\tSpinLockRelease(&walrcv->mutex);\n\t\t\telog(PANIC, \"walreceiver still running according to shared memory state\");\n\t}\n\t/* Advertise our PID so that the startup process can kill us */\n\twalrcv->pid = MyProcPid;\n\twalrcv->walRcvState = WALRCV_STREAMING;\n\n\t/* Fetch information required to start streaming */\n\twalrcv->ready_to_display = false;\n\tstrlcpy(conninfo, (char *) walrcv->conninfo, MAXCONNINFO);\n\tstrlcpy(slotname, (char *) walrcv->slotname, NAMEDATALEN);\n\tis_temp_slot = walrcv->is_temp_slot;\n\tstartpoint = walrcv->receiveStart;\n\tstartpointTLI = walrcv->receiveStartTLI;\n\n\t/*\n\t * At most one of is_temp_slot and slotname can be set; otherwise,\n\t * RequestXLogStreaming messed up.\n\t */\n\tAssert(!is_temp_slot || (slotname[0] == '\\0'));\n\n\t/* Initialise to a sanish value */\n\tnow = GetCurrentTimestamp();\n\twalrcv->lastMsgSendTime =\n\t\twalrcv->lastMsgReceiptTime = walrcv->latestWalEndTime = now;\n\n\t/* Report the latch to use to awaken this process */\n\twalrcv->latch = &MyProc->procLatch;\n\n\tSpinLockRelease(&walrcv->mutex);\n\n\tpg_atomic_write_u64(&WalRcv->writtenUpto, 0);\n\n\t/* Arrange to clean up at walreceiver exit */\n\ton_shmem_exit(WalRcvDie, PointerGetDatum(&startpointTLI));\n\n\t/* Properly accept or ignore signals the postmaster might send us */\n\tpqsignal(SIGHUP, SignalHandlerForConfigReload); /* set flag to read config\n\t\t\t\t\t\t\t\t\t\t\t\t\t * file */\n\tpqsignal(SIGINT, SIG_IGN);\n\tpqsignal(SIGTERM, SignalHandlerForShutdownRequest); /* request shutdown */\n\t/* SIGQUIT handler was already set up by InitPostmasterChild */\n\tpqsignal(SIGALRM, SIG_IGN);\n\tpqsignal(SIGPIPE, SIG_IGN);\n\tpqsignal(SIGUSR1, procsignal_sigusr1_handler);\n\tpqsignal(SIGUSR2, SIG_IGN);\n\n\t/* Reset some signals that are accepted by postmaster but not here */\n\tpqsignal(SIGCHLD, SIG_DFL);\n\n\t/* Load the libpq-specific functions */\n\tload_file(\"libpqwalreceiver\", false);\n\tif (WalReceiverFunctions == NULL)\n\t\telog(ERROR, \"libpqwalreceiver didn't initialize correctly\");\n\n\t/* Unblock signals (they were blocked when the postmaster forked us) */\n\tsigprocmask(SIG_SETMASK, &UnBlockSig, NULL);\n\n\t/* Establish the connection to the primary for XLOG streaming */\n\twrconn = walrcv_connect(conninfo, false, false,\n\t\t\t\t\t\t\tcluster_name[0] ? cluster_name : \"walreceiver\",\n\t\t\t\t\t\t\t&err);\n\tif (!wrconn)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CONNECTION_FAILURE),\n\t\t\t\t errmsg(\"could not connect to the primary server: %s\", err)));\n\n\t/*\n\t * Save user-visible connection string.  This clobbers the original\n\t * conninfo, for security. Also save host and port of the sender server\n\t * this walreceiver is connected to.\n\t */\n\ttmp_conninfo = walrcv_get_conninfo(wrconn);\n\twalrcv_get_senderinfo(wrconn, &sender_host, &sender_port);\n\tSpinLockAcquire(&walrcv->mutex);\n\tmemset(walrcv->conninfo, 0, MAXCONNINFO);\n\tif (tmp_conninfo)\n\t\tstrlcpy((char *) walrcv->conninfo, tmp_conninfo, MAXCONNINFO);\n\n\tmemset(walrcv->sender_host, 0, NI_MAXHOST);\n\tif (sender_host)\n\t\tstrlcpy((char *) walrcv->sender_host, sender_host, NI_MAXHOST);\n\n\twalrcv->sender_port = sender_port;\n\twalrcv->ready_to_display = true;\n\tSpinLockRelease(&walrcv->mutex);\n\n\tif (tmp_conninfo)\n\t\tpfree(tmp_conninfo);\n\n\tif (sender_host)\n\t\tpfree(sender_host);\n\n\tfirst_stream = true;\n\tfor (;;)\n\t{\n\t\tchar\t   *primary_sysid;\n\t\tchar\t\tstandby_sysid[32];\n\t\tWalRcvStreamOptions options;\n\n\t\t/*\n\t\t * Check that we're connected to a valid server using the\n\t\t * IDENTIFY_SYSTEM replication command.\n\t\t */\n\t\tprimary_sysid = walrcv_identify_system(wrconn, &primaryTLI);\n\n\t\tsnprintf(standby_sysid, sizeof(standby_sysid), UINT64_FORMAT,\n\t\t\t\t GetSystemIdentifier());\n\t\tif (strcmp(primary_sysid, standby_sysid) != 0)\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"database system identifier differs between the primary and standby\"),\n\t\t\t\t\t errdetail(\"The primary's identifier is %s, the standby's identifier is %s.\",\n\t\t\t\t\t\t\t   primary_sysid, standby_sysid)));\n\t\t}\n\n\t\t/*\n\t\t * Confirm that the current timeline of the primary is the same or\n\t\t * ahead of ours.\n\t\t */\n\t\tif (primaryTLI < startpointTLI)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"highest timeline %u of the primary is behind recovery timeline %u\",\n\t\t\t\t\t\t\tprimaryTLI, startpointTLI)));\n\n\t\t/*\n\t\t * Get any missing history files. We do this always, even when we're\n\t\t * not interested in that timeline, so that if we're promoted to\n\t\t * become the primary later on, we don't select the same timeline that\n\t\t * was already used in the current primary. This isn't bullet-proof -\n\t\t * you'll need some external software to manage your cluster if you\n\t\t * need to ensure that a unique timeline id is chosen in every case,\n\t\t * but let's avoid the confusion of timeline id collisions where we\n\t\t * can.\n\t\t */\n\t\tWalRcvFetchTimeLineHistoryFiles(startpointTLI, primaryTLI);\n\n\t\t/*\n\t\t * Create temporary replication slot if requested, and update slot\n\t\t * name in shared memory.  (Note the slot name cannot already be set\n\t\t * in this case.)\n\t\t */\n\t\tif (is_temp_slot)\n\t\t{\n\t\t\tsnprintf(slotname, sizeof(slotname),\n\t\t\t\t\t \"pg_walreceiver_%lld\",\n\t\t\t\t\t (long long int) walrcv_get_backend_pid(wrconn));\n\n\t\t\twalrcv_create_slot(wrconn, slotname, true, false, 0, NULL);\n\n\t\t\tSpinLockAcquire(&walrcv->mutex);\n\t\t\tstrlcpy(walrcv->slotname, slotname, NAMEDATALEN);\n\t\t\tSpinLockRelease(&walrcv->mutex);\n\t\t}\n\n\t\t/*\n\t\t * Start streaming.\n\t\t *\n\t\t * We'll try to start at the requested starting point and timeline,\n\t\t * even if it's different from the server's latest timeline. In case\n\t\t * we've already reached the end of the old timeline, the server will\n\t\t * finish the streaming immediately, and we will go back to await\n\t\t * orders from the startup process. If recovery_target_timeline is\n\t\t * 'latest', the startup process will scan pg_wal and find the new\n\t\t * history file, bump recovery target timeline, and ask us to restart\n\t\t * on the new timeline.\n\t\t */\n\t\toptions.logical = false;\n\t\toptions.startpoint = startpoint;\n\t\toptions.slotname = slotname[0] != '\\0' ? slotname : NULL;\n\t\toptions.proto.physical.startpointTLI = startpointTLI;\n\t\tif (walrcv_startstreaming(wrconn, &options))\n\t\t{\n\t\t\tif (first_stream)\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"started streaming WAL from primary at %X/%X on timeline %u\",\n\t\t\t\t\t\t\t\tLSN_FORMAT_ARGS(startpoint), startpointTLI)));\n\t\t\telse\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"restarted WAL streaming at %X/%X on timeline %u\",\n\t\t\t\t\t\t\t\tLSN_FORMAT_ARGS(startpoint), startpointTLI)));\n\t\t\tfirst_stream = false;\n\n\t\t\t/* Initialize LogstreamResult and buffers for processing messages */\n\t\t\tLogstreamResult.Write = LogstreamResult.Flush = GetXLogReplayRecPtr(NULL);\n\t\t\tinitStringInfo(&reply_message);\n\t\t\tinitStringInfo(&incoming_message);\n\n\t\t\t/* Initialize nap wakeup times. */\n\t\t\tnow = GetCurrentTimestamp();\n\t\t\tfor (int i = 0; i < NUM_WALRCV_WAKEUPS; ++i)\n\t\t\t\tWalRcvComputeNextWakeup(i, now);\n\n\t\t\t/* Send initial reply/feedback messages. */\n\t\t\tXLogWalRcvSendReply(true, false);\n\t\t\tXLogWalRcvSendHSFeedback(true);\n\n\t\t\t/* Loop until end-of-streaming or error */\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tchar\t   *buf;\n\t\t\t\tint\t\t\tlen;\n\t\t\t\tbool\t\tendofwal = false;\n\t\t\t\tpgsocket\twait_fd = PGINVALID_SOCKET;\n\t\t\t\tint\t\t\trc;\n\t\t\t\tTimestampTz nextWakeup;\n\t\t\t\tlong\t\tnap;\n\n\t\t\t\t/*\n\t\t\t\t * Exit walreceiver if we're not in recovery. This should not\n\t\t\t\t * happen, but cross-check the status here.\n\t\t\t\t */\n\t\t\t\tif (!RecoveryInProgress())\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t\t\t errmsg(\"cannot continue WAL streaming, recovery has already ended\")));\n\n\t\t\t\t/* Process any requests or signals received recently */\n\t\t\t\tProcessWalRcvInterrupts();\n\n\t\t\t\tif (ConfigReloadPending)\n\t\t\t\t{\n\t\t\t\t\tConfigReloadPending = false;\n\t\t\t\t\tProcessConfigFile(PGC_SIGHUP);\n\t\t\t\t\t/* recompute wakeup times */\n\t\t\t\t\tnow = GetCurrentTimestamp();\n\t\t\t\t\tfor (int i = 0; i < NUM_WALRCV_WAKEUPS; ++i)\n\t\t\t\t\t\tWalRcvComputeNextWakeup(i, now);\n\t\t\t\t\tXLogWalRcvSendHSFeedback(true);\n\t\t\t\t}\n\n\t\t\t\t/* See if we can read data immediately */\n\t\t\t\tlen = walrcv_receive(wrconn, &buf, &wait_fd);\n\t\t\t\tif (len != 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Process the received data, and any subsequent data we\n\t\t\t\t\t * can read without blocking.\n\t\t\t\t\t */\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (len > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Something was received from primary, so adjust\n\t\t\t\t\t\t\t * the ping and terminate wakeup times.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tnow = GetCurrentTimestamp();\n\t\t\t\t\t\t\tWalRcvComputeNextWakeup(WALRCV_WAKEUP_TERMINATE,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnow);\n\t\t\t\t\t\t\tWalRcvComputeNextWakeup(WALRCV_WAKEUP_PING, now);\n\t\t\t\t\t\t\tXLogWalRcvProcessMsg(buf[0], &buf[1], len - 1,\n\t\t\t\t\t\t\t\t\t\t\t\t startpointTLI);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (len == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if (len < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tereport(LOG,\n\t\t\t\t\t\t\t\t\t(errmsg(\"replication terminated by primary server\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"End of WAL reached on timeline %u at %X/%X.\",\n\t\t\t\t\t\t\t\t\t\t\t   startpointTLI,\n\t\t\t\t\t\t\t\t\t\t\t   LSN_FORMAT_ARGS(LogstreamResult.Write))));\n\t\t\t\t\t\t\tendofwal = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = walrcv_receive(wrconn, &buf, &wait_fd);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Let the primary know that we received some data. */\n\t\t\t\t\tXLogWalRcvSendReply(false, false);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If we've written some records, flush them to disk and\n\t\t\t\t\t * let the startup process and primary server know about\n\t\t\t\t\t * them.\n\t\t\t\t\t */\n\t\t\t\t\tXLogWalRcvFlush(false, startpointTLI);\n\t\t\t\t}\n\n\t\t\t\t/* Check if we need to exit the streaming loop. */\n\t\t\t\tif (endofwal)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* Find the soonest wakeup time, to limit our nap. */\n\t\t\t\tnextWakeup = TIMESTAMP_INFINITY;\n\t\t\t\tfor (int i = 0; i < NUM_WALRCV_WAKEUPS; ++i)\n\t\t\t\t\tnextWakeup = Min(wakeup[i], nextWakeup);\n\n\t\t\t\t/* Calculate the nap time, clamping as necessary. */\n\t\t\t\tnow = GetCurrentTimestamp();\n\t\t\t\tnap = TimestampDifferenceMilliseconds(now, nextWakeup);\n\n\t\t\t\t/*\n\t\t\t\t * Ideally we would reuse a WaitEventSet object repeatedly\n\t\t\t\t * here to avoid the overheads of WaitLatchOrSocket on epoll\n\t\t\t\t * systems, but we can't be sure that libpq (or any other\n\t\t\t\t * walreceiver implementation) has the same socket (even if\n\t\t\t\t * the fd is the same number, it may have been closed and\n\t\t\t\t * reopened since the last time).  In future, if there is a\n\t\t\t\t * function for removing sockets from WaitEventSet, then we\n\t\t\t\t * could add and remove just the socket each time, potentially\n\t\t\t\t * avoiding some system calls.\n\t\t\t\t */\n\t\t\t\tAssert(wait_fd != PGINVALID_SOCKET);\n\t\t\t\trc = WaitLatchOrSocket(MyLatch,\n\t\t\t\t\t\t\t\t\t   WL_EXIT_ON_PM_DEATH | WL_SOCKET_READABLE |\n\t\t\t\t\t\t\t\t\t   WL_TIMEOUT | WL_LATCH_SET,\n\t\t\t\t\t\t\t\t\t   wait_fd,\n\t\t\t\t\t\t\t\t\t   nap,\n\t\t\t\t\t\t\t\t\t   WAIT_EVENT_WAL_RECEIVER_MAIN);\n\t\t\t\tif (rc & WL_LATCH_SET)\n\t\t\t\t{\n\t\t\t\t\tResetLatch(MyLatch);\n\t\t\t\t\tProcessWalRcvInterrupts();\n\n\t\t\t\t\tif (walrcv->force_reply)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The recovery process has asked us to send apply\n\t\t\t\t\t\t * feedback now.  Make sure the flag is really set to\n\t\t\t\t\t\t * false in shared memory before sending the reply, so\n\t\t\t\t\t\t * we don't miss a new request for a reply.\n\t\t\t\t\t\t */\n\t\t\t\t\t\twalrcv->force_reply = false;\n\t\t\t\t\t\tpg_memory_barrier();\n\t\t\t\t\t\tXLogWalRcvSendReply(true, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rc & WL_TIMEOUT)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We didn't receive anything new. If we haven't heard\n\t\t\t\t\t * anything from the server for more than\n\t\t\t\t\t * wal_receiver_timeout / 2, ping the server. Also, if\n\t\t\t\t\t * it's been longer than wal_receiver_status_interval\n\t\t\t\t\t * since the last update we sent, send a status update to\n\t\t\t\t\t * the primary anyway, to report any progress in applying\n\t\t\t\t\t * WAL.\n\t\t\t\t\t */\n\t\t\t\t\tbool\t\trequestReply = false;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Check if time since last receive from primary has\n\t\t\t\t\t * reached the configured limit.\n\t\t\t\t\t */\n\t\t\t\t\tnow = GetCurrentTimestamp();\n\t\t\t\t\tif (now >= wakeup[WALRCV_WAKEUP_TERMINATE])\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CONNECTION_FAILURE),\n\t\t\t\t\t\t\t\t errmsg(\"terminating walreceiver due to timeout\")));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If we didn't receive anything new for half of receiver\n\t\t\t\t\t * replication timeout, then ping the server.\n\t\t\t\t\t */\n\t\t\t\t\tif (now >= wakeup[WALRCV_WAKEUP_PING])\n\t\t\t\t\t{\n\t\t\t\t\t\trequestReply = true;\n\t\t\t\t\t\twakeup[WALRCV_WAKEUP_PING] = TIMESTAMP_INFINITY;\n\t\t\t\t\t}\n\n\t\t\t\t\tXLogWalRcvSendReply(requestReply, requestReply);\n\t\t\t\t\tXLogWalRcvSendHSFeedback(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The backend finished streaming. Exit streaming COPY-mode from\n\t\t\t * our side, too.\n\t\t\t */\n\t\t\twalrcv_endstreaming(wrconn, &primaryTLI);\n\n\t\t\t/*\n\t\t\t * If the server had switched to a new timeline that we didn't\n\t\t\t * know about when we began streaming, fetch its timeline history\n\t\t\t * file now.\n\t\t\t */\n\t\t\tWalRcvFetchTimeLineHistoryFiles(startpointTLI, primaryTLI);\n\t\t}\n\t\telse\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"primary server contains no more WAL on requested timeline %u\",\n\t\t\t\t\t\t\tstartpointTLI)));\n\n\t\t/*\n\t\t * End of WAL reached on the requested timeline. Close the last\n\t\t * segment, and await for new orders from the startup process.\n\t\t */\n\t\tif (recvFile >= 0)\n\t\t{\n\t\t\tchar\t\txlogfname[MAXFNAMELEN];\n\n\t\t\tXLogWalRcvFlush(false, startpointTLI);\n\t\t\tXLogFileName(xlogfname, recvFileTLI, recvSegNo, wal_segment_size);\n\t\t\tif (close(recvFile) != 0)\n\t\t\t\tereport(PANIC,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not close WAL segment %s: %m\",\n\t\t\t\t\t\t\t\txlogfname)));\n\n\t\t\t/*\n\t\t\t * Create .done file forcibly to prevent the streamed segment from\n\t\t\t * being archived later.\n\t\t\t */\n\t\t\tif (XLogArchiveMode != ARCHIVE_MODE_ALWAYS)\n\t\t\t\tXLogArchiveForceDone(xlogfname);\n\t\t\telse\n\t\t\t\tXLogArchiveNotify(xlogfname);\n\t\t}\n\t\trecvFile = -1;\n\n\t\telog(DEBUG1, \"walreceiver ended streaming and awaits new instructions\");\n\t\tWalRcvWaitForStartPosition(&startpoint, &startpointTLI);\n\t}\n\t/* not reached */\n}",
  "timestamp": "2025-10-30T15:57:26.994908"
}