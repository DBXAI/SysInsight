{
  "param_name": "work_mem",
  "function_name": "get_relation_info",
  "analysis": "1. Parameters influence database performance by controlling key functions:\n   - `work_mem` affects `get_relation_info` through memory usage mechanisms, potentially causing memory overflow or insufficiency issues, thus impacting database performance.\n   - Mechanism: The `work_mem` parameter determines the amount of memory available for a single query operation. When `get_relation_info` processes a large amount of index information or statistics, it may use a significant amount of memory. If `work_mem` is set too low, it may result in more use of temporary files on disk, thereby reducing performance.\n   - Impact on database performance: Improperly set `work_mem` may lead to an imbalance in CPU and I/O resource usage, with insufficient memory causing excessive reliance on disk, thereby reducing query performance. Conversely, setting it too high may lead to memory waste or contention, affecting the operation of other processes.\n\n2. Based on the execution state of `get_relation_info` and related function segments, provide `work_mem` optimization suggestions:\n   - If there are many operational functions involved, such as `RelationGetIndexList` and `index_open`, it is necessary to monitor the relationship between these functions and `get_relation_info` to assess their memory consumption.\n   - If `get_relation_info` occupies a high proportion in flame graph sampling and shows insufficient memory usage issues (frequent disk I/O), it is recommended to moderately increase the `work_mem` value to reduce external memory usage. Conversely, if excessive memory usage is observed without achieving the desired performance improvement, it is advisable to lower the `work_mem` value to ensure reasonable allocation of memory resources. This is based on flame graph characteristics of low memory utilization or high I/O waited time.",
  "code_snippets": "get_relation_info(PlannerInfo *root, Oid relationObjectId, bool inhparent,\n\t\t\t\t  RelOptInfo *rel)\n{\n\tIndex\t\tvarno = rel->relid;\n\tRelation\trelation;\n\tbool\t\thasindex;\n\tList\t   *indexinfos = NIL;\n\n\t/*\n\t * We need not lock the relation since it was already locked, either by\n\t * the rewriter or when expand_inherited_rtentry() added it to the query's\n\t * rangetable.\n\t */\n\trelation = table_open(relationObjectId, NoLock);\n\n\t/*\n\t * Relations without a table AM can be used in a query only if they are of\n\t * special-cased relkinds.  This check prevents us from crashing later if,\n\t * for example, a view's ON SELECT rule has gone missing.  Note that\n\t * table_open() already rejected indexes and composite types; spell the\n\t * error the same way it does.\n\t */\n\tif (!relation->rd_tableam)\n\t{\n\t\tif (!(relation->rd_rel->relkind == RELKIND_FOREIGN_TABLE ||\n\t\t\t  relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"cannot open relation \\\"%s\\\"\",\n\t\t\t\t\t\t\tRelationGetRelationName(relation)),\n\t\t\t\t\t errdetail_relkind_not_supported(relation->rd_rel->relkind)));\n\t}\n\n\t/* Temporary and unlogged relations are inaccessible during recovery. */\n\tif (!RelationIsPermanent(relation) && RecoveryInProgress())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot access temporary or unlogged relations during recovery\")));\n\n\trel->min_attr = FirstLowInvalidHeapAttributeNumber + 1;\n\trel->max_attr = RelationGetNumberOfAttributes(relation);\n\trel->reltablespace = RelationGetForm(relation)->reltablespace;\n\n\tAssert(rel->max_attr >= rel->min_attr);\n\trel->attr_needed = (Relids *)\n\t\tpalloc0((rel->max_attr - rel->min_attr + 1) * sizeof(Relids));\n\trel->attr_widths = (int32 *)\n\t\tpalloc0((rel->max_attr - rel->min_attr + 1) * sizeof(int32));\n\n\t/*\n\t * Estimate relation size --- unless it's an inheritance parent, in which\n\t * case the size we want is not the rel's own size but the size of its\n\t * inheritance tree.  That will be computed in set_append_rel_size().\n\t */\n\tif (!inhparent)\n\t\testimate_rel_size(relation, rel->attr_widths - rel->min_attr,\n\t\t\t\t\t\t  &rel->pages, &rel->tuples, &rel->allvisfrac);\n\n\t/* Retrieve the parallel_workers reloption, or -1 if not set. */\n\trel->rel_parallel_workers = RelationGetParallelWorkers(relation, -1);\n\n\t/*\n\t * Make list of indexes.  Ignore indexes on system catalogs if told to.\n\t * Don't bother with indexes from traditional inheritance parents.  For\n\t * partitioned tables, we need a list of at least unique indexes as these\n\t * serve as unique proofs for certain planner optimizations.  However,\n\t * let's not discriminate here and just record all partitioned indexes\n\t * whether they're unique indexes or not.\n\t */\n\tif ((inhparent && relation->rd_rel->relkind != RELKIND_PARTITIONED_TABLE)\n\t\t|| (IgnoreSystemIndexes && IsSystemRelation(relation)))\n\t\thasindex = false;\n\telse\n\t\thasindex = relation->rd_rel->relhasindex;\n\n\tif (hasindex)\n\t{\n\t\tList\t   *indexoidlist;\n\t\tLOCKMODE\tlmode;\n\t\tListCell   *l;\n\n\t\tindexoidlist = RelationGetIndexList(relation);\n\n\t\t/*\n\t\t * For each index, we get the same type of lock that the executor will\n\t\t * need, and do not release it.  This saves a couple of trips to the\n\t\t * shared lock manager while not creating any real loss of\n\t\t * concurrency, because no schema changes could be happening on the\n\t\t * index while we hold lock on the parent rel, and no lock type used\n\t\t * for queries blocks any other kind of index operation.\n\t\t */\n\t\tlmode = root->simple_rte_array[varno]->rellockmode;\n\n\t\tforeach(l, indexoidlist)\n\t\t{\n\t\t\tOid\t\t\tindexoid = lfirst_oid(l);\n\t\t\tRelation\tindexRelation;\n\t\t\tForm_pg_index index;\n\t\t\tIndexAmRoutine *amroutine;\n\t\t\tIndexOptInfo *info;\n\t\t\tint\t\t\tncolumns,\n\t\t\t\t\t\tnkeycolumns;\n\t\t\tint\t\t\ti;\n\n\t\t\t/*\n\t\t\t * Extract info from the relation descriptor for the index.\n\t\t\t */\n\t\t\tindexRelation = index_open(indexoid, lmode);\n\t\t\tindex = indexRelation->rd_index;\n\n\t\t\t/*\n\t\t\t * Ignore invalid indexes, since they can't safely be used for\n\t\t\t * queries.  Note that this is OK because the data structure we\n\t\t\t * are constructing is only used by the planner --- the executor\n\t\t\t * still needs to insert into \"invalid\" indexes, if they're marked\n\t\t\t * indisready.\n\t\t\t */\n\t\t\tif (!index->indisvalid)\n\t\t\t{\n\t\t\t\tindex_close(indexRelation, NoLock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the index is valid, but cannot yet be used, ignore it; but\n\t\t\t * mark the plan we are generating as transient. See\n\t\t\t * src/backend/access/heap/README.HOT for discussion.\n\t\t\t */\n\t\t\tif (index->indcheckxmin &&\n\t\t\t\t!TransactionIdPrecedes(HeapTupleHeaderGetXmin(indexRelation->rd_indextuple->t_data),\n\t\t\t\t\t\t\t\t\t   TransactionXmin))\n\t\t\t{\n\t\t\t\troot->glob->transientPlan = true;\n\t\t\t\tindex_close(indexRelation, NoLock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinfo = makeNode(IndexOptInfo);\n\n\t\t\tinfo->indexoid = index->indexrelid;\n\t\t\tinfo->reltablespace =\n\t\t\t\tRelationGetForm(indexRelation)->reltablespace;\n\t\t\tinfo->rel = rel;\n\t\t\tinfo->ncolumns = ncolumns = index->indnatts;\n\t\t\tinfo->nkeycolumns = nkeycolumns = index->indnkeyatts;\n\n\t\t\tinfo->indexkeys = (int *) palloc(sizeof(int) * ncolumns);\n\t\t\tinfo->indexcollations = (Oid *) palloc(sizeof(Oid) * nkeycolumns);\n\t\t\tinfo->opfamily = (Oid *) palloc(sizeof(Oid) * nkeycolumns);\n\t\t\tinfo->opcintype = (Oid *) palloc(sizeof(Oid) * nkeycolumns);\n\t\t\tinfo->canreturn = (bool *) palloc(sizeof(bool) * ncolumns);\n\n\t\t\tfor (i = 0; i < ncolumns; i++)\n\t\t\t{\n\t\t\t\tinfo->indexkeys[i] = index->indkey.values[i];\n\t\t\t\tinfo->canreturn[i] = index_can_return(indexRelation, i + 1);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < nkeycolumns; i++)\n\t\t\t{\n\t\t\t\tinfo->opfamily[i] = indexRelation->rd_opfamily[i];\n\t\t\t\tinfo->opcintype[i] = indexRelation->rd_opcintype[i];\n\t\t\t\tinfo->indexcollations[i] = indexRelation->rd_indcollation[i];\n\t\t\t}\n\n\t\t\tinfo->relam = indexRelation->rd_rel->relam;\n\n\t\t\t/*\n\t\t\t * We don't have an AM for partitioned indexes, so we'll just\n\t\t\t * NULLify the AM related fields for those.\n\t\t\t */\n\t\t\tif (indexRelation->rd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t\t{\n\t\t\t\t/* We copy just the fields we need, not all of rd_indam */\n\t\t\t\tamroutine = indexRelation->rd_indam;\n\t\t\t\tinfo->amcanorderbyop = amroutine->amcanorderbyop;\n\t\t\t\tinfo->amoptionalkey = amroutine->amoptionalkey;\n\t\t\t\tinfo->amsearcharray = amroutine->amsearcharray;\n\t\t\t\tinfo->amsearchnulls = amroutine->amsearchnulls;\n\t\t\t\tinfo->amcanparallel = amroutine->amcanparallel;\n\t\t\t\tinfo->amhasgettuple = (amroutine->amgettuple != NULL);\n\t\t\t\tinfo->amhasgetbitmap = amroutine->amgetbitmap != NULL &&\n\t\t\t\t\trelation->rd_tableam->scan_bitmap_next_block != NULL;\n\t\t\t\tinfo->amcanmarkpos = (amroutine->ammarkpos != NULL &&\n\t\t\t\t\t\t\t\t\t  amroutine->amrestrpos != NULL);\n\t\t\t\tinfo->amcostestimate = amroutine->amcostestimate;\n\t\t\t\tAssert(info->amcostestimate != NULL);\n\n\t\t\t\t/* Fetch index opclass options */\n\t\t\t\tinfo->opclassoptions = RelationGetIndexAttOptions(indexRelation, true);\n\n\t\t\t\t/*\n\t\t\t\t * Fetch the ordering information for the index, if any.\n\t\t\t\t */\n\t\t\t\tif (info->relam == BTREE_AM_OID)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If it's a btree index, we can use its opfamily OIDs\n\t\t\t\t\t * directly as the sort ordering opfamily OIDs.\n\t\t\t\t\t */\n\t\t\t\t\tAssert(amroutine->amcanorder);\n\n\t\t\t\t\tinfo->sortopfamily = info->opfamily;\n\t\t\t\t\tinfo->reverse_sort = (bool *) palloc(sizeof(bool) * nkeycolumns);\n\t\t\t\t\tinfo->nulls_first = (bool *) palloc(sizeof(bool) * nkeycolumns);\n\n\t\t\t\t\tfor (i = 0; i < nkeycolumns; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint16\t\topt = indexRelation->rd_indoption[i];\n\n\t\t\t\t\t\tinfo->reverse_sort[i] = (opt & INDOPTION_DESC) != 0;\n\t\t\t\t\t\tinfo->nulls_first[i] = (opt & INDOPTION_NULLS_FIRST) != 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (amroutine->amcanorder)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Otherwise, identify the corresponding btree opfamilies\n\t\t\t\t\t * by trying to map this index's \"<\" operators into btree.\n\t\t\t\t\t * Since \"<\" uniquely defines the behavior of a sort\n\t\t\t\t\t * order, this is a sufficient test.\n\t\t\t\t\t *\n\t\t\t\t\t * XXX This method is rather slow and also requires the\n\t\t\t\t\t * undesirable assumption that the other index AM numbers\n\t\t\t\t\t * its strategies the same as btree.  It'd be better to\n\t\t\t\t\t * have a way to explicitly declare the corresponding\n\t\t\t\t\t * btree opfamily for each opfamily of the other index\n\t\t\t\t\t * type.  But given the lack of current or foreseeable\n\t\t\t\t\t * amcanorder index types, it's not worth expending more\n\t\t\t\t\t * effort on now.\n\t\t\t\t\t */\n\t\t\t\t\tinfo->sortopfamily = (Oid *) palloc(sizeof(Oid) * nkeycolumns);\n\t\t\t\t\tinfo->reverse_sort = (bool *) palloc(sizeof(bool) * nkeycolumns);\n\t\t\t\t\tinfo->nulls_first = (bool *) palloc(sizeof(bool) * nkeycolumns);\n\n\t\t\t\t\tfor (i = 0; i < nkeycolumns; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint16\t\topt = indexRelation->rd_indoption[i];\n\t\t\t\t\t\tOid\t\t\tltopr;\n\t\t\t\t\t\tOid\t\t\tbtopfamily;\n\t\t\t\t\t\tOid\t\t\tbtopcintype;\n\t\t\t\t\t\tint16\t\tbtstrategy;\n\n\t\t\t\t\t\tinfo->reverse_sort[i] = (opt & INDOPTION_DESC) != 0;\n\t\t\t\t\t\tinfo->nulls_first[i] = (opt & INDOPTION_NULLS_FIRST) != 0;\n\n\t\t\t\t\t\tltopr = get_opfamily_member(info->opfamily[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\tinfo->opcintype[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\tinfo->opcintype[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\tBTLessStrategyNumber);\n\t\t\t\t\t\tif (OidIsValid(ltopr) &&\n\t\t\t\t\t\t\tget_ordering_op_properties(ltopr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &btopfamily,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &btopcintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &btstrategy) &&\n\t\t\t\t\t\t\tbtopcintype == info->opcintype[i] &&\n\t\t\t\t\t\t\tbtstrategy == BTLessStrategyNumber)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Successful mapping */\n\t\t\t\t\t\t\tinfo->sortopfamily[i] = btopfamily;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Fail ... quietly treat index as unordered */\n\t\t\t\t\t\t\tinfo->sortopfamily = NULL;\n\t\t\t\t\t\t\tinfo->reverse_sort = NULL;\n\t\t\t\t\t\t\tinfo->nulls_first = NULL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinfo->sortopfamily = NULL;\n\t\t\t\t\tinfo->reverse_sort = NULL;\n\t\t\t\t\tinfo->nulls_first = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinfo->amcanorderbyop = false;\n\t\t\t\tinfo->amoptionalkey = false;\n\t\t\t\tinfo->amsearcharray = false;\n\t\t\t\tinfo->amsearchnulls = false;\n\t\t\t\tinfo->amcanparallel = false;\n\t\t\t\tinfo->amhasgettuple = false;\n\t\t\t\tinfo->amhasgetbitmap = false;\n\t\t\t\tinfo->amcanmarkpos = false;\n\t\t\t\tinfo->amcostestimate = NULL;\n\n\t\t\t\tinfo->sortopfamily = NULL;\n\t\t\t\tinfo->reverse_sort = NULL;\n\t\t\t\tinfo->nulls_first = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Fetch the index expressions and predicate, if any.  We must\n\t\t\t * modify the copies we obtain from the relcache to have the\n\t\t\t * correct varno for the parent relation, so that they match up\n\t\t\t * correctly against qual clauses.\n\t\t\t */\n\t\t\tinfo->indexprs = RelationGetIndexExpressions(indexRelation);\n\t\t\tinfo->indpred = RelationGetIndexPredicate(indexRelation);\n\t\t\tif (info->indexprs && varno != 1)\n\t\t\t\tChangeVarNodes((Node *) info->indexprs, 1, varno, 0);\n\t\t\tif (info->indpred && varno != 1)\n\t\t\t\tChangeVarNodes((Node *) info->indpred, 1, varno, 0);\n\n\t\t\t/* Build targetlist using the completed indexprs data */\n\t\t\tinfo->indextlist = build_index_tlist(root, info, relation);\n\n\t\t\tinfo->indrestrictinfo = NIL;\t/* set later, in indxpath.c */\n\t\t\tinfo->predOK = false;\t/* set later, in indxpath.c */\n\t\t\tinfo->unique = index->indisunique;\n\t\t\tinfo->immediate = index->indimmediate;\n\t\t\tinfo->hypothetical = false;\n\n\t\t\t/*\n\t\t\t * Estimate the index size.  If it's not a partial index, we lock\n\t\t\t * the number-of-tuples estimate to equal the parent table; if it\n\t\t\t * is partial then we have to use the same methods as we would for\n\t\t\t * a table, except we can be sure that the index is not larger\n\t\t\t * than the table.  We must ignore partitioned indexes here as\n\t\t\t * there are not physical indexes.\n\t\t\t */\n\t\t\tif (indexRelation->rd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t\t{\n\t\t\t\tif (info->indpred == NIL)\n\t\t\t\t{\n\t\t\t\t\tinfo->pages = RelationGetNumberOfBlocks(indexRelation);\n\t\t\t\t\tinfo->tuples = rel->tuples;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdouble\t\tallvisfrac; /* dummy */\n\n\t\t\t\t\testimate_rel_size(indexRelation, NULL,\n\t\t\t\t\t\t\t\t\t  &info->pages, &info->tuples, &allvisfrac);\n\t\t\t\t\tif (info->tuples > rel->tuples)\n\t\t\t\t\t\tinfo->tuples = rel->tuples;\n\t\t\t\t}\n\n\t\t\t\tif (info->relam == BTREE_AM_OID)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * For btrees, get tree height while we have the index\n\t\t\t\t\t * open\n\t\t\t\t\t */\n\t\t\t\t\tinfo->tree_height = _bt_getrootheight(indexRelation);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* For other index types, just set it to \"unknown\" for now */\n\t\t\t\t\tinfo->tree_height = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Zero these out for partitioned indexes */\n\t\t\t\tinfo->pages = 0;\n\t\t\t\tinfo->tuples = 0.0;\n\t\t\t\tinfo->tree_height = -1;\n\t\t\t}\n\n\t\t\tindex_close(indexRelation, NoLock);\n\n\t\t\t/*\n\t\t\t * We've historically used lcons() here.  It'd make more sense to\n\t\t\t * use lappend(), but that causes the planner to change behavior\n\t\t\t * in cases where two indexes seem equally attractive.  For now,\n\t\t\t * stick with lcons() --- few tables should have so many indexes\n\t\t\t * that the O(N^2) behavior of lcons() is really a problem.\n\t\t\t */\n\t\t\tindexinfos = lcons(info, indexinfos);\n\t\t}\n\n\t\tlist_free(indexoidlist);\n\t}\n\n\trel->indexlist = indexinfos;\n\n\trel->statlist = get_relation_statistics(rel, relation);\n\n\t/* Grab foreign-table info using the relcache, while we have it */\n\tif (relation->rd_rel->relkind == RELKIND_FOREIGN_TABLE)\n\t{\n\t\trel->serverid = GetForeignServerIdByRelId(RelationGetRelid(relation));\n\t\trel->fdwroutine = GetFdwRoutineForRelation(relation, true);\n\t}\n\telse\n\t{\n\t\trel->serverid = InvalidOid;\n\t\trel->fdwroutine = NULL;\n\t}\n\n\t/* Collect info about relation's foreign keys, if relevant */\n\tget_relation_foreign_keys(root, rel, relation, inhparent);\n\n\t/* Collect info about functions implemented by the rel's table AM. */\n\tif (relation->rd_tableam &&\n\t\trelation->rd_tableam->scan_set_tidrange != NULL &&\n\t\trelation->rd_tableam->scan_getnextslot_tidrange != NULL)\n\t\trel->amflags |= AMFLAG_HAS_TID_RANGE;\n\n\t/*\n\t * Collect info about relation's partitioning scheme, if any. Only\n\t * inheritance parents may be partitioned.\n\t */\n\tif (inhparent && relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)\n\t\tset_relation_partition_info(root, rel, relation);\n\n\ttable_close(relation, NoLock);\n\n\t/*\n\t * Allow a plugin to editorialize on the info we obtained from the\n\t * catalogs.  Actions might include altering the assumed relation size,\n\t * removing an index, or adding a hypothetical index to the indexlist.\n\t */\n\tif (get_relation_info_hook)\n\t\t(*get_relation_info_hook) (root, relationObjectId, inhparent, rel);\n}",
  "timestamp": "2025-10-30T15:57:52.011446"
}